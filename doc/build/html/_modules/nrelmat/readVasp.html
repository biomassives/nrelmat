<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>nrelmat.readVasp &mdash; nrelmat 1.0.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="nrelmat 1.0.0 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">nrelmat 1.0.0 documentation</a> &raquo;</li>
          <li><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for nrelmat.readVasp</h1><div class="highlight"><pre>
<span class="c">#!/usr/bin/env python</span>
<span class="c"># Copyright 2013 National Renewable Energy Laboratory, Golden CO, USA</span>
<span class="c"># This file is part of NREL MatDB.</span>
<span class="c">#</span>
<span class="c"># NREL MatDB is free software: you can redistribute it and/or modify</span>
<span class="c"># it under the terms of the GNU General Public License as published by</span>
<span class="c"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c"># (at your option) any later version.</span>
<span class="c">#</span>
<span class="c"># NREL MatDB is distributed in the hope that it will be useful,</span>
<span class="c"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c"># GNU General Public License for more details.</span>
<span class="c">#</span>
<span class="c"># You should have received a copy of the GNU General Public License</span>
<span class="c"># along with NREL MatDB.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>


<span class="kn">import</span> <span class="nn">datetime</span><span class="o">,</span> <span class="nn">re</span><span class="o">,</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">traceback</span><span class="o">,</span> <span class="nn">os.path</span>
<span class="kn">import</span> <span class="nn">xml.etree.cElementTree</span> <span class="kn">as</span> <span class="nn">etree</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>


<span class="c">#====================================================================</span>

<div class="viewcode-block" id="ResClass"><a class="viewcode-back" href="../../readVasp.html#nrelmat.readVasp.ResClass">[docs]</a><span class="k">class</span> <span class="nc">ResClass</span><span class="p">:</span>
  <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  An empty class used as a data container for parseDir results.</span>

<span class="sd">  The parseDir function will call either parsePylada or parseXml,</span>
<span class="sd">  and they will save the VASP results as attributes of</span>
<span class="sd">  an instance of ResClass.</span>
<span class="sd">  &#39;&#39;&#39;</span>

  <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="n">keys</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
      <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
      <span class="n">stg</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span> <span class="n">val</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">stg</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span> <span class="n">sep</span> <span class="o">=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
      <span class="k">else</span><span class="p">:</span> <span class="n">sep</span> <span class="o">=</span> <span class="s">&#39; &#39;</span>
      <span class="n">msg</span> <span class="o">+=</span> <span class="s">&#39;  </span><span class="si">%s</span><span class="s">:  type: </span><span class="si">%s</span><span class="s">  val:</span><span class="si">%s%s</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">sep</span><span class="p">,</span> <span class="n">val</span><span class="p">,)</span>
    <span class="k">return</span> <span class="n">msg</span>

<span class="c">#====================================================================</span>

</div>
<span class="k">def</span> <span class="nf">badparms</span><span class="p">(</span> <span class="n">msg</span><span class="p">):</span>
  <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">Error: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">msg</span><span class="p">,)</span>
  <span class="k">print</span> <span class="s">&#39;Parms:&#39;</span>
  <span class="k">print</span> <span class="s">&#39;  -bugLev    &lt;int&gt;      debug level&#39;</span>
  <span class="k">print</span> <span class="s">&#39;  -inType    &lt;string&gt;   pylada / xml&#39;</span>
  <span class="k">print</span> <span class="s">&#39;  -inDir     &lt;string&gt;   dir containing input OUTCAR or vasprun.xml&#39;</span>
  <span class="k">print</span> <span class="s">&#39;  -maxLev    &lt;int&gt;      max levels to print for xml&#39;</span>
  <span class="k">print</span> <span class="s">&#39;&#39;</span>
  <span class="k">print</span> <span class="s">&#39;Examples:&#39;</span>
  <span class="k">print</span> <span class="s">&#39;./readVasp.py -bugLev 5   -inType xml   -inDir tda/testlada.2013.04.15.fe.len.3.20/icsd_044729/icsd_044729.cif/hs-anti-ferro-0/relax_cellshape/0   -maxLev 0&#39;</span>
  <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c">#====================================================================</span>


<div class="viewcode-block" id="main"><a class="viewcode-back" href="../../readVasp.html#nrelmat.readVasp.main">[docs]</a><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
  <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Test driver: Extracts info from the output of a VASP run.</span>

<span class="sd">  Command line parameters:</span>

<span class="sd">  ================  =========    ==============================================</span>
<span class="sd">  Parameter         Type         Description</span>
<span class="sd">  ================  =========    ==============================================</span>
<span class="sd">  **-bugLev**       integer      Debug level.  Normally 0.</span>
<span class="sd">  **-inType**       string       If &#39;pylada&#39;, read the OUTCAR file.</span>
<span class="sd">                                 Else if &#39;xml&#39;, read the vasprun.xml file.</span>
<span class="sd">  **-inDir**        string       Input directory containing OUTCAR</span>
<span class="sd">                                 and/or vasprun.xml.</span>
<span class="sd">  **-maxLev**       int          Max number of levels to print for xml</span>
<span class="sd">  ================  =========    ==============================================</span>
<span class="sd">  &#39;&#39;&#39;</span>

  <span class="n">bugLev</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">inType</span> <span class="o">=</span> <span class="bp">None</span>
  <span class="n">inDir</span> <span class="o">=</span> <span class="bp">None</span>
  <span class="n">maxLev</span> <span class="o">=</span> <span class="bp">None</span>

  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">badparms</span><span class="p">(</span><span class="s">&#39;Parms must be key/value pairs&#39;</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">iarg</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="n">iarg</span><span class="p">]</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="n">iarg</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s">&#39;-bugLev&#39;</span><span class="p">:</span> <span class="n">bugLev</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">val</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s">&#39;-inType&#39;</span><span class="p">:</span> <span class="n">inType</span> <span class="o">=</span> <span class="n">val</span>
    <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s">&#39;-inDir&#39;</span><span class="p">:</span> <span class="n">inDir</span> <span class="o">=</span> <span class="n">val</span>
    <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s">&#39;-maxLev&#39;</span><span class="p">:</span> <span class="n">maxLev</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">val</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="n">badparms</span><span class="p">(</span><span class="s">&#39;unknown key: &quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,))</span>

  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span> <span class="n">badparms</span><span class="p">(</span><span class="s">&#39;parm not specified: -bugLev&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">inType</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span> <span class="n">badparms</span><span class="p">(</span><span class="s">&#39;parm not specified: -inType&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">inDir</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span> <span class="n">badparms</span><span class="p">(</span><span class="s">&#39;parm not specified: -inDir&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">maxLev</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span> <span class="n">badparms</span><span class="p">(</span><span class="s">&#39;parm not specified: -maxLev&#39;</span><span class="p">)</span>

  <span class="c">##np.set_printoptions( threshold=10000)</span>

  <span class="n">resObj</span> <span class="o">=</span> <span class="n">parseDir</span><span class="p">(</span> <span class="n">bugLev</span><span class="p">,</span> <span class="n">inType</span><span class="p">,</span> <span class="n">inDir</span><span class="p">,</span> <span class="n">maxLev</span><span class="p">)</span>

  <span class="k">print</span> <span class="s">&#39;main: resObj:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="p">,)</span>


<span class="c">#====================================================================</span>


<span class="c"># Returns ResClass instance.</span>
</div>
<div class="viewcode-block" id="parseDir"><a class="viewcode-back" href="../../readVasp.html#nrelmat.readVasp.parseDir">[docs]</a><span class="k">def</span> <span class="nf">parseDir</span><span class="p">(</span>
  <span class="n">bugLev</span><span class="p">,</span>
  <span class="n">inType</span><span class="p">,</span>
  <span class="n">inDir</span><span class="p">,</span>
  <span class="n">maxLev</span><span class="p">):</span>
  <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Extracts info from the output of a VASP run.</span>

<span class="sd">  **Parameters**:</span>

<span class="sd">  * bugLev (int): Debug level.  Normally 0.</span>
<span class="sd">  * inType (str): If &#39;pylada&#39;, read the OUTCAR file.</span>
<span class="sd">    Else if &#39;xml&#39;, read the vasprun.xml file.</span>
<span class="sd">  * inDir (str): Input directory containing OUTCAR</span>
<span class="sd">    and/or vasprun.xml.</span>
<span class="sd">  * max (int) Max number of levels to print for xml</span>

<span class="sd">  **Returns**:</span>

<span class="sd">  * resObj (class ResClass): data object with attributes set.</span>
<span class="sd">  &#39;&#39;&#39;</span>

  <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">inDir</span><span class="p">):</span>
    <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;inDir is not a dir: &quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">inDir</span><span class="p">,))</span>

  <span class="n">resObj</span> <span class="o">=</span> <span class="n">ResClass</span><span class="p">()</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">excTrace</span> <span class="o">=</span> <span class="bp">None</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">excMsg</span> <span class="o">=</span> <span class="bp">None</span>

  <span class="k">try</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">inType</span> <span class="o">==</span> <span class="s">&#39;pylada&#39;</span><span class="p">:</span>
      <span class="n">inFile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span> <span class="n">inDir</span><span class="p">,</span> <span class="s">&#39;OUTCAR&#39;</span><span class="p">)</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">inFile</span><span class="p">):</span>
        <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;inFile is not a file: &quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">inFile</span><span class="p">,))</span>
      <span class="n">parsePylada</span><span class="p">(</span> <span class="n">bugLev</span><span class="p">,</span> <span class="n">inFile</span><span class="p">,</span> <span class="n">resObj</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">inType</span> <span class="o">==</span> <span class="s">&#39;xml&#39;</span><span class="p">:</span>
      <span class="n">inFile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span> <span class="n">inDir</span><span class="p">,</span> <span class="s">&#39;vasprun.xml&#39;</span><span class="p">)</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">inFile</span><span class="p">):</span>
        <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;inFile is not a file: &quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">inFile</span><span class="p">,))</span>
      <span class="n">parseXml</span><span class="p">(</span> <span class="n">bugLev</span><span class="p">,</span> <span class="n">inFile</span><span class="p">,</span> <span class="n">maxLev</span><span class="p">,</span> <span class="n">resObj</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;unknown inType: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">inType</span><span class="p">,))</span>
  <span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">exc</span><span class="p">:</span>
    <span class="n">resObj</span><span class="o">.</span><span class="n">excTrace</span> <span class="o">=</span> <span class="n">traceback</span><span class="o">.</span><span class="n">format_exc</span><span class="p">(</span> <span class="n">limit</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
    <span class="n">resObj</span><span class="o">.</span><span class="n">excMsg</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&#39;readVasp.py.  caught exc: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">excMsg</span><span class="p">,)</span>
    <span class="k">print</span> <span class="s">&#39;  inType:   &quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">inType</span><span class="p">,)</span>
    <span class="k">print</span> <span class="s">&#39;  inDir:    &quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">inDir</span><span class="p">,)</span>
    <span class="k">print</span> <span class="s">&#39;===== traceback start =====&#39;</span>
    <span class="k">print</span> <span class="n">resObj</span><span class="o">.</span><span class="n">excTrace</span>
    <span class="k">print</span> <span class="s">&#39;===== traceback end =====&#39;</span>
    <span class="n">throwerr</span><span class="p">(</span> <span class="n">exc</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">resObj</span>

<span class="c">#====================================================================</span>
</div>
<div class="viewcode-block" id="parsePylada"><a class="viewcode-back" href="../../readVasp.html#nrelmat.readVasp.parsePylada">[docs]</a><span class="k">def</span> <span class="nf">parsePylada</span><span class="p">(</span> <span class="n">bugLev</span><span class="p">,</span> <span class="n">inFile</span><span class="p">,</span> <span class="n">resObj</span><span class="p">):</span>
  <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Extracts info from the OUTCAR file from a VASP run,</span>
<span class="sd">  using the PyLada vasp.Extract API.</span>

<span class="sd">  **Parameters**:</span>

<span class="sd">  * bugLev (int): Debug level.  Normally 0.</span>
<span class="sd">  * inFile (str): Path of the input OUTCAR file.</span>
<span class="sd">  * resObj (class ResClass): data object: we set attributes here.</span>

<span class="sd">  **Returns**:</span>

<span class="sd">  * None</span>
<span class="sd">  &#39;&#39;&#39;</span>

  <span class="kn">import</span> <span class="nn">pylada.vasp</span>

  <span class="n">ex</span> <span class="o">=</span> <span class="n">pylada</span><span class="o">.</span><span class="n">vasp</span><span class="o">.</span><span class="n">Extract</span><span class="p">(</span> <span class="n">inFile</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">ex</span><span class="o">.</span><span class="n">success</span><span class="p">:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;file </span><span class="si">%s</span><span class="s"> is not complete&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">inFile</span><span class="p">,))</span>

  <span class="c">#===== program, version, date etc =====</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">runDate</span>      <span class="o">=</span> <span class="n">ex</span><span class="o">.</span><span class="n">datetime</span>

  <span class="c"># iterTimes are pairs: [cpuTime, realTime]</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">iterCpuTimes</span>   <span class="o">=</span> <span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">ex</span><span class="o">.</span><span class="n">iterTimes</span><span class="p">]</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">iterRealTimes</span>  <span class="o">=</span> <span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">ex</span><span class="o">.</span><span class="n">iterTimes</span><span class="p">]</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">iterTotalTime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">iterRealTimes</span><span class="p">)</span>

  <span class="c">#===== incar parameters =====</span>
  <span class="c"># Use float() to get rid of Quantities units</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">algo</span>         <span class="o">=</span> <span class="n">ex</span><span class="o">.</span><span class="n">algo</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">ediff</span>        <span class="o">=</span> <span class="nb">float</span><span class="p">(</span> <span class="n">ex</span><span class="o">.</span><span class="n">ediff</span><span class="p">)</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">encut_ev</span>     <span class="o">=</span> <span class="nb">float</span><span class="p">(</span> <span class="n">ex</span><span class="o">.</span><span class="n">encut</span><span class="p">)</span>          <span class="c"># eV</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">ibrion</span>       <span class="o">=</span> <span class="n">ex</span><span class="o">.</span><span class="n">ibrion</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">isif</span>         <span class="o">=</span> <span class="n">ex</span><span class="o">.</span><span class="n">isif</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">systemName</span>   <span class="o">=</span> <span class="n">ex</span><span class="o">.</span><span class="n">system</span>
  <span class="c">#===== general parameters =====</span>
  <span class="c">#===== electronic parameters =====</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">ialgo</span>        <span class="o">=</span> <span class="n">ex</span><span class="o">.</span><span class="n">ialgo</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">numBand</span>      <span class="o">=</span> <span class="n">ex</span><span class="o">.</span><span class="n">nbands</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">numElectron</span>  <span class="o">=</span> <span class="n">ex</span><span class="o">.</span><span class="n">nelect</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">icharg</span>       <span class="o">=</span> <span class="n">ex</span><span class="o">.</span><span class="n">icharg</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">numSpin</span>      <span class="o">=</span> <span class="n">ex</span><span class="o">.</span><span class="n">ispin</span>


  <span class="c">#===== atom info =====</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">typeNames</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">ex</span><span class="o">.</span><span class="n">species</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">typeNums</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">ex</span><span class="o">.</span><span class="n">stoichiometry</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">typeValences</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">ex</span><span class="o">.</span><span class="n">ionic_charges</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

  <span class="c"># totalValence = sum( count[i] * valence[i])</span>
  <span class="c"># PyLada calls this valence.</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">totalValence</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">typeNums</span><span class="p">,</span> <span class="n">resObj</span><span class="o">.</span><span class="n">typeValences</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;totalValence: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">totalValence</span><span class="p">,)</span>
  <span class="k">if</span> <span class="n">resObj</span><span class="o">.</span><span class="n">numElectron</span> <span class="o">!=</span> <span class="n">resObj</span><span class="o">.</span><span class="n">totalValence</span><span class="p">:</span>
    <span class="c"># xxx should this be an error?</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%g</span><span class="s"> == numElectron != totalValence == </span><span class="si">%g</span><span class="s">&#39;</span> \
      <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">numElectron</span><span class="p">,</span> <span class="n">resObj</span><span class="o">.</span><span class="n">totalValence</span><span class="p">,))</span>

  <span class="n">struct</span> <span class="o">=</span> <span class="n">ex</span><span class="o">.</span><span class="n">structure</span>
  <span class="n">natom</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="n">struct</span><span class="p">)</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">atomNames</span> <span class="o">=</span> <span class="p">[</span> <span class="n">struct</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">type</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">natom</span><span class="p">)]</span>

  <span class="n">resObj</span><span class="o">.</span><span class="n">atomMasses_amu</span> <span class="o">=</span> <span class="bp">None</span>      <span class="c"># not available</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">atomPseudos</span> <span class="o">=</span> <span class="bp">None</span>         <span class="c"># not available</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">atomValences</span> <span class="o">=</span> <span class="bp">None</span>        <span class="c"># not available</span>

  <span class="c"># atomPseudos: only the first title is available</span>
  <span class="c"># atomMass, Valence: not available</span>

  <span class="c"># partial_charges and magnetization are not available in xml</span>
  <span class="c"># resObj.partialChargeMat = ex.partial_charges</span>
  <span class="c"># resObj.magnetizationMat = ex.magnetization</span>

  <span class="c">#===== initial structure =====</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">initialBasisMat</span> <span class="o">=</span> <span class="n">ex</span><span class="o">.</span><span class="n">initial_structure</span><span class="o">.</span><span class="n">cell</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">initialRecipBasisMat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">initialBasisMat</span><span class="p">)</span>

  <span class="n">struct</span> <span class="o">=</span> <span class="n">ex</span><span class="o">.</span><span class="n">initial_structure</span>
  <span class="n">natom</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="n">struct</span><span class="p">)</span>
  <span class="n">cartPos</span> <span class="o">=</span> <span class="n">natom</span> <span class="o">*</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span>
  <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">natom</span><span class="p">):</span>
    <span class="n">cartPos</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">struct</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">pos</span>      <span class="c"># no units</span>

  <span class="n">resObj</span><span class="o">.</span><span class="n">initialCartesianPosMat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">cartPos</span><span class="p">)</span>

  <span class="n">resObj</span><span class="o">.</span><span class="n">initialDirectPosMat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
    <span class="n">resObj</span><span class="o">.</span><span class="n">initialCartesianPosMat</span><span class="p">,</span> <span class="n">resObj</span><span class="o">.</span><span class="n">initialRecipBasisMat</span><span class="p">)</span>

  <span class="c">#===== final structure =====</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">finalBasisMat</span> <span class="o">=</span> <span class="n">ex</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">cell</span>

  <span class="c"># xxx: not quite true:</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">finalRecipBasisMat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">finalBasisMat</span><span class="p">)</span>

  <span class="n">struct</span> <span class="o">=</span> <span class="n">ex</span><span class="o">.</span><span class="n">structure</span>
  <span class="n">natom</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="n">struct</span><span class="p">)</span>
  <span class="n">cartPos</span> <span class="o">=</span> <span class="n">natom</span> <span class="o">*</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span>
  <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">natom</span><span class="p">):</span>
    <span class="n">cartPos</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">struct</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">pos</span>

  <span class="n">resObj</span><span class="o">.</span><span class="n">finalCartesianPosMat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">cartPos</span><span class="p">)</span>

  <span class="n">resObj</span><span class="o">.</span><span class="n">finalDirectPosMat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
    <span class="n">resObj</span><span class="o">.</span><span class="n">finalCartesianPosMat</span><span class="p">,</span> <span class="n">resObj</span><span class="o">.</span><span class="n">finalRecipBasisMat</span><span class="p">)</span>

  <span class="c">#===== kpoints =====</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">kpointRecipSpaceCartCoords</span> <span class="o">=</span> <span class="n">ex</span><span class="o">.</span><span class="n">kpoints</span>    <span class="c"># transform</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">numKpoint</span> <span class="o">=</span> <span class="n">resObj</span><span class="o">.</span><span class="n">kpointRecipSpaceCartCoords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">kpointWeights</span> <span class="o">=</span> <span class="bp">None</span>          <span class="c"># xxx not available</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">kpointRecipSpaceFracCoords</span> <span class="o">=</span> \
    <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">kpointRecipSpaceCartCoords</span><span class="p">,</span> <span class="n">resObj</span><span class="o">.</span><span class="n">initialBasisMat</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;numKpoint: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">numKpoint</span><span class="p">,)</span>
    <span class="k">print</span> <span class="s">&#39;kpointRecipSpaceFracCoords:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> \
      <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">kpointRecipSpaceFracCoords</span><span class="p">),)</span>
    <span class="k">print</span> <span class="s">&#39;kpointRecipSpaceCartCoords:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> \
      <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">kpointRecipSpaceCartCoords</span><span class="p">),)</span>
  <span class="c">#===== final volume and density =====</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">finalVolumeVasp_ang3</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span> <span class="n">ex</span><span class="o">.</span><span class="n">volume</span><span class="p">)</span>     <span class="c"># Angstrom^3</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">density_g_cm3</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span> <span class="n">ex</span><span class="o">.</span><span class="n">density</span><span class="p">)</span>           <span class="c"># g/cm3</span>
  <span class="c">#===== last calc forces =====</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">finalForceMat_ev_ang</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">ex</span><span class="o">.</span><span class="n">forces</span><span class="p">)</span>  <span class="c"># eV/angstrom</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">finalStressMat_kbar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">ex</span><span class="o">.</span><span class="n">stress</span><span class="p">)</span>   <span class="c"># kbar</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">finalPressure_kbar</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span> <span class="n">ex</span><span class="o">.</span><span class="n">pressure</span><span class="p">)</span>     <span class="c"># kbar</span>
  <span class="c">#===== eigenvalues and occupancies =====</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">eigenMat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">ex</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">)</span>
  <span class="c"># Caution: for non-magnetic, OUTCAR occMat = 2 while vasprun.xml = 1.</span>
  <span class="c"># For magnetic, OUTCAR and vasprun.xml both have 1.</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">occMat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">ex</span><span class="o">.</span><span class="n">occupations</span><span class="p">)</span>
  <span class="c">#===== misc junk =====</span>
  <span class="c">#===== energy, efermi0 =====</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">energyNoEntrp</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span> <span class="n">ex</span><span class="o">.</span><span class="n">total_energy</span><span class="p">)</span>         <span class="c"># eV</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">efermi0</span>      <span class="o">=</span> <span class="nb">float</span><span class="p">(</span> <span class="n">ex</span><span class="o">.</span><span class="n">fermi0K</span><span class="p">)</span>               <span class="c"># eV</span>
  <span class="c">#===== cbMin, vbMax, bandgap =====</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">cbMin</span>        <span class="o">=</span> <span class="nb">float</span><span class="p">(</span> <span class="n">ex</span><span class="o">.</span><span class="n">cbm</span><span class="p">)</span>                   <span class="c"># eV</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">vbMax</span>        <span class="o">=</span> <span class="nb">float</span><span class="p">(</span> <span class="n">ex</span><span class="o">.</span><span class="n">vbm</span><span class="p">)</span>                   <span class="c"># eV</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">bandgap</span>      <span class="o">=</span> <span class="n">resObj</span><span class="o">.</span><span class="n">cbMin</span> <span class="o">-</span> <span class="n">resObj</span><span class="o">.</span><span class="n">vbMax</span>      <span class="c"># eV</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;cbMin: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">cbMin</span><span class="p">,)</span>
    <span class="k">print</span> <span class="s">&#39;vbMax: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">vbMax</span><span class="p">,)</span>
    <span class="k">print</span> <span class="s">&#39;bandgap:  </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">bandgap</span><span class="p">,)</span>

  <span class="n">resObj</span><span class="o">.</span><span class="n">cbms</span>         <span class="o">=</span> <span class="bp">None</span>                  <span class="c"># not available</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">vbms</span>         <span class="o">=</span> <span class="bp">None</span>                  <span class="c"># not available</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">cbmKpis</span>      <span class="o">=</span> <span class="bp">None</span>                  <span class="c"># not available</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">vbmKpis</span>      <span class="o">=</span> <span class="bp">None</span>                  <span class="c"># not available</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">bandgapa</span>     <span class="o">=</span> <span class="bp">None</span>                  <span class="c"># not available</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">bandgaps</span>     <span class="o">=</span> <span class="bp">None</span>                  <span class="c"># not available</span>

  <span class="k">return</span>

<span class="c"># xxx to do:</span>
<span class="c">#   energy               == totalEnergy</span>
<span class="c">#   energy_sigma0        totalEnergySigma0</span>
<span class="c">#   fermi0K              fermi0</span>
<span class="c">#   fermi_energy         fermiEnergy</span>
<span class="c">#   total_energy         totalEnergy</span>
<span class="c"># array(-13.916343) * eV</span>

<span class="c">#====================================================================</span>
</div>
<div class="viewcode-block" id="parseXml"><a class="viewcode-back" href="../../readVasp.html#nrelmat.readVasp.parseXml">[docs]</a><span class="k">def</span> <span class="nf">parseXml</span><span class="p">(</span> <span class="n">bugLev</span><span class="p">,</span> <span class="n">inXml</span><span class="p">,</span> <span class="n">maxLev</span><span class="p">,</span> <span class="n">resObj</span><span class="p">):</span>
  <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Extracts info from the vasprun.xml file from a VASP run,</span>
<span class="sd">  using the Python xml.etree.cElementTree API.</span>

<span class="sd">  **Parameters**:</span>

<span class="sd">  * bugLev (int): Debug level.  Normally 0.</span>
<span class="sd">  * inFile (str): Path of the input OUTCAR file.</span>
<span class="sd">  * resObj (class ResClass): data object: we set attributes here.</span>

<span class="sd">  **Returns**:</span>

<span class="sd">  * None</span>
<span class="sd">  &#39;&#39;&#39;</span>

  <span class="n">tree</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span> <span class="n">inXml</span><span class="p">)</span>
  <span class="n">root</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">getroot</span><span class="p">()</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span> <span class="n">printNode</span><span class="p">(</span> <span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">maxLev</span><span class="p">)</span>      <span class="c"># node, curLev, maxLev</span>

  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">===== program, version, date etc =====</span><span class="se">\n</span><span class="s">&#39;</span>

  <span class="c"># xxx program, version, subversion, etc</span>

  <span class="c"># PyLada: vasp/extract/base.py: datetime()</span>
  <span class="c"># OUTCAR: use the 1 occurance of:</span>
  <span class="c">#   executed on             LinuxIFC date 2013.03.11  09:32:24</span>
  <span class="n">dtStg</span> <span class="o">=</span> <span class="n">getString</span><span class="p">(</span> <span class="n">root</span><span class="p">,</span> <span class="s">&#39;generator/i[@name=</span><span class="se">\&#39;</span><span class="s">date</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">)</span>
  <span class="n">tmStg</span> <span class="o">=</span> <span class="n">getString</span><span class="p">(</span> <span class="n">root</span><span class="p">,</span> <span class="s">&#39;generator/i[@name=</span><span class="se">\&#39;</span><span class="s">time</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">)</span>
  <span class="n">dateFmtIn</span> <span class="o">=</span> <span class="s">&#39;%Y %m </span><span class="si">%d</span><span class="s"> %H:%M:%S&#39;</span>
  <span class="n">dateFmtOut</span> <span class="o">=</span> <span class="s">&#39;%Y-%m-</span><span class="si">%d</span><span class="s"> %H:%M:%S&#39;</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">runDate</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span>
    <span class="s">&#39;</span><span class="si">%s</span><span class="s"> </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dtStg</span><span class="p">,</span> <span class="n">tmStg</span><span class="p">),</span> <span class="n">dateFmtIn</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;runDate: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">runDate</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span> <span class="n">dateFmtOut</span><span class="p">),)</span>


  <span class="c"># iterTimes</span>
  <span class="c"># Each node is has cpuTime, wallTime:</span>
  <span class="c">#       &lt;time name=&#39;totalsc&#39;&gt;22.49 24.43&lt;/time&gt;</span>
  <span class="n">nodes</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;calculation/time[@name=</span><span class="se">\&#39;</span><span class="s">totalsc</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">)</span>
  <span class="n">iterCpuTimes</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">iterRealTimes</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
    <span class="n">txt</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">text</span>
    <span class="n">toks</span> <span class="o">=</span> <span class="n">txt</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">toks</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;invalid times: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">node</span><span class="p">,))</span>
    <span class="n">iterCpuTimes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="nb">float</span><span class="p">(</span> <span class="n">toks</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">iterRealTimes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="nb">float</span><span class="p">(</span> <span class="n">toks</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">iterCpuTimes</span> <span class="o">=</span> <span class="n">iterCpuTimes</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">iterRealTimes</span> <span class="o">=</span> <span class="n">iterRealTimes</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">iterTotalTime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">iterRealTimes</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;iterCpuTimes: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">iterCpuTimes</span><span class="p">,)</span>
    <span class="k">print</span> <span class="s">&#39;iterRealTimes: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">iterRealTimes</span><span class="p">,)</span>
    <span class="k">print</span> <span class="s">&#39;iterTotalTime: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">iterTotalTime</span><span class="p">,)</span>


  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">===== incar parameters =====</span><span class="se">\n</span><span class="s">&#39;</span>

  <span class="c"># algo</span>
  <span class="c"># PyLada: vasp/extract/base.py: algo()</span>
  <span class="c"># OUTCAR: use the 1 occurance of:</span>
  <span class="c">#   ALGO = Fast</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">algo</span> <span class="o">=</span> <span class="n">getString</span><span class="p">(</span> <span class="n">root</span><span class="p">,</span> <span class="s">&#39;incar/i[@name=</span><span class="se">\&#39;</span><span class="s">ALGO</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;algo: &quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">algo</span><span class="p">,)</span>

  <span class="n">ediff</span> <span class="o">=</span> <span class="n">getScalar</span><span class="p">(</span> <span class="n">root</span><span class="p">,</span> <span class="s">&#39;incar/i[@name=</span><span class="se">\&#39;</span><span class="s">EDIFF</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">ediff</span> <span class="o">=</span> <span class="n">ediff</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;ediff: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ediff</span><span class="p">,)</span>

  <span class="c"># encut</span>
  <span class="c"># PyLada: vasp/extract/base.py: encut()</span>
  <span class="c"># OUTCAR: use the first occurance of:</span>
  <span class="c">#   ENCUT  =  252.0 eV  18.52 Ry    4.30 a.u.   4.08  4.08 15.92*2*pi/ulx,y,z</span>
  <span class="c">#   ENCUT = 252.0</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">encut_ev</span> <span class="o">=</span> <span class="n">getScalar</span><span class="p">(</span> <span class="n">root</span><span class="p">,</span> <span class="s">&#39;incar/i[@name=</span><span class="se">\&#39;</span><span class="s">ENCUT</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;encut_ev: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">encut_ev</span><span class="p">,)</span>

  <span class="n">resObj</span><span class="o">.</span><span class="n">ibrion</span> <span class="o">=</span> <span class="n">getScalar</span><span class="p">(</span> <span class="n">root</span><span class="p">,</span> <span class="s">&#39;incar/i[@name=</span><span class="se">\&#39;</span><span class="s">IBRION</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;ibrion: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">ibrion</span><span class="p">,)</span>

  <span class="n">resObj</span><span class="o">.</span><span class="n">isif</span> <span class="o">=</span> <span class="n">getScalar</span><span class="p">(</span> <span class="n">root</span><span class="p">,</span> <span class="s">&#39;incar/i[@name=</span><span class="se">\&#39;</span><span class="s">ISIF</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;isif: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">isif</span><span class="p">,)</span>

  <span class="c"># ldauType</span>
  <span class="c"># PyLada: vasp/extract/base.py: LDAUType()</span>
  <span class="c"># OUTCAR: use the first occurance of:</span>
  <span class="c">#   LDA+U is selected, type is set to LDAUTYPE =  2</span>
  <span class="c">#   LDAUTYPE = 2</span>
  <span class="c">#rawLdauType = getScalar( root, &#39;incar/v[@name=\&#39;LDAUTYPE\&#39;]&#39;, int)</span>
  <span class="c">#if rawLdauType == 1: resObj.ldauType = &#39;liechtenstein&#39;</span>
  <span class="c">#elif rawLdauType == 2: resObj.ldauType = &#39;dudarev&#39;</span>
  <span class="c">#else: throwerr(&#39;unknown rawLdauType: %d&#39; % (rawLdauType,))</span>
  <span class="c">#if bugLev &gt;= 5:</span>
  <span class="c">#  print &#39;rawLdauType: %d  ldauType: %s&#39; % (rawLdauType, resObj.ldauType,)</span>

  <span class="n">resObj</span><span class="o">.</span><span class="n">systemName</span> <span class="o">=</span> <span class="n">getString</span><span class="p">(</span> <span class="n">root</span><span class="p">,</span> <span class="s">&#39;incar/i[@name=</span><span class="se">\&#39;</span><span class="s">SYSTEM</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;systemName: &quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">systemName</span><span class="p">,)</span>



  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">===== general parameters =====</span><span class="se">\n</span><span class="s">&#39;</span>

  <span class="n">resObj</span><span class="o">.</span><span class="n">generalName</span> <span class="o">=</span> <span class="n">getString</span><span class="p">(</span>
    <span class="n">root</span><span class="p">,</span> <span class="s">&#39;parameters/separator[@name=</span><span class="se">\&#39;</span><span class="s">general</span><span class="se">\&#39;</span><span class="s">]/i[@name=</span><span class="se">\&#39;</span><span class="s">SYSTEM</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;generalName: &quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">generalName</span><span class="p">,)</span>



  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">===== electronic parameters =====</span><span class="se">\n</span><span class="s">&#39;</span>

  <span class="n">lst</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;parameters/separator[@name=</span><span class="se">\&#39;</span><span class="s">electronic</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;electronic parameters not found&#39;</span><span class="p">)</span>
  <span class="n">elecNode</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

  <span class="c"># ialgo</span>
  <span class="c"># PyLada: use the 1 occurance of:</span>
  <span class="c">#   Electronic relaxation 2 (details)</span>
  <span class="c">#     IALGO  =     68    algorithm</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">ialgo</span> <span class="o">=</span> <span class="n">getScalar</span><span class="p">(</span> <span class="n">elecNode</span><span class="p">,</span> <span class="s">&#39;i[@name=</span><span class="se">\&#39;</span><span class="s">IALGO</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;ialgo: </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">ialgo</span><span class="p">,)</span>

  <span class="c"># numBand = nbands</span>
  <span class="c"># Caution: in some cases NBANDS != eigenMrr[&#39;eigene&#39;].shape[2]</span>
  <span class="c"># So we use the eigene dimension instead.</span>
  <span class="c"># See further below.</span>
  <span class="n">prmNumBand</span> <span class="o">=</span> <span class="n">getScalar</span><span class="p">(</span> <span class="n">elecNode</span><span class="p">,</span> <span class="s">&#39;i[@name=</span><span class="se">\&#39;</span><span class="s">NBANDS</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;prmNumBand: </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">prmNumBand</span><span class="p">,)</span>

  <span class="c"># numElectron = nelect</span>
  <span class="c"># PyLada: vasp/extract/base.py: nelect()</span>
  <span class="c"># OUTCAR: use the 1 occurance of:</span>
  <span class="c">#     NELECT =      48.0000    total number of electrons</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">numElectron</span> <span class="o">=</span> <span class="n">getScalar</span><span class="p">(</span> <span class="n">elecNode</span><span class="p">,</span> <span class="s">&#39;i[@name=</span><span class="se">\&#39;</span><span class="s">NELECT</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;numElectron: </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">numElectron</span><span class="p">,)</span>

  <span class="c"># icharg</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">icharg</span> <span class="o">=</span> <span class="n">getScalar</span><span class="p">(</span>
    <span class="n">elecNode</span><span class="p">,</span>
    <span class="s">&#39;separator[@name=</span><span class="se">\&#39;</span><span class="s">electronic startup</span><span class="se">\&#39;</span><span class="s">]/i[@name=</span><span class="se">\&#39;</span><span class="s">ICHARG</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">,</span>
    <span class="nb">int</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;icharg: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">icharg</span><span class="p">,)</span>

  <span class="c"># numSpin == ispin</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">numSpin</span> <span class="o">=</span> <span class="n">getScalar</span><span class="p">(</span>
    <span class="n">elecNode</span><span class="p">,</span> <span class="s">&#39;separator[@name=</span><span class="se">\&#39;</span><span class="s">electronic spin</span><span class="se">\&#39;</span><span class="s">]/i[@name=</span><span class="se">\&#39;</span><span class="s">ISPIN</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;numSpin: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">numSpin</span><span class="p">,)</span>


  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">===== atom info =====</span><span class="se">\n</span><span class="s">&#39;</span>

  <span class="c"># atomTypeMrr = map containing array.  Example (some whitespace omitted):</span>
  <span class="c">#   _dimLens: [2]</span>
  <span class="c">#   _dimNames: [&#39;type&#39;]</span>
  <span class="c">#   _fieldNames: [&#39;atomspertype&#39; &#39;element&#39; &#39;mass&#39; &#39;valence&#39; &#39;pseudopotential&#39;]</span>
  <span class="c">#   _fieldTypes: [&#39;i&#39; &#39;s&#39; &#39;f&#39; &#39;f&#39; &#39;s&#39;]</span>
  <span class="c">#   atomspertype: [1 4]</span>
  <span class="c">#   element: [&#39;C &#39; &#39;Fe&#39;]</span>
  <span class="c">#   mass: [ 12.011  55.847]</span>
  <span class="c">#   valence: [ 4.  8.]</span>
  <span class="c">#   pseudopotential: [&#39; PAW_PBE C_s 06Sep2000 &#39; &#39; PAW_PBE Fe 06Sep2000 &#39;]</span>

  <span class="n">atomTypeMrr</span> <span class="o">=</span> <span class="n">getArrayByPath</span><span class="p">(</span>
    <span class="n">bugLev</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="s">&#39;atominfo/array[@name=</span><span class="se">\&#39;</span><span class="s">atomtypes</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">)</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">typeNames</span>       <span class="o">=</span> <span class="n">atomTypeMrr</span><span class="p">[</span><span class="s">&#39;element&#39;</span><span class="p">]</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">typeNums</span>        <span class="o">=</span> <span class="n">atomTypeMrr</span><span class="p">[</span><span class="s">&#39;atomspertype&#39;</span><span class="p">]</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">typeMasses_amu</span>  <span class="o">=</span> <span class="n">atomTypeMrr</span><span class="p">[</span><span class="s">&#39;mass&#39;</span><span class="p">]</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">typeValences</span>    <span class="o">=</span> <span class="n">atomTypeMrr</span><span class="p">[</span><span class="s">&#39;valence&#39;</span><span class="p">]</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">typePseudos</span>     <span class="o">=</span> <span class="n">atomTypeMrr</span><span class="p">[</span><span class="s">&#39;pseudopotential&#39;</span><span class="p">]</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">atomTypeMrr:&#39;</span>
    <span class="n">printMrr</span><span class="p">(</span> <span class="n">atomTypeMrr</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&#39;typeNames: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">typeNames</span><span class="p">,)</span>
    <span class="k">print</span> <span class="s">&#39;typeNums: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">typeNums</span><span class="p">,)</span>
    <span class="k">print</span> <span class="s">&#39;typeMasses_amu: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">typeMasses_amu</span><span class="p">,)</span>
    <span class="k">print</span> <span class="s">&#39;typeValences: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">typeValences</span><span class="p">,)</span>
    <span class="k">print</span> <span class="s">&#39;typePseudos: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">typePseudos</span><span class="p">,)</span>

  <span class="c"># totalValence = sum( count[i] * valence[i])</span>
  <span class="c"># PyLada calls this valence.</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">totalValence</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">typeNums</span><span class="p">,</span> <span class="n">resObj</span><span class="o">.</span><span class="n">typeValences</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;totalValence: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">totalValence</span><span class="p">,)</span>

  <span class="k">if</span> <span class="n">resObj</span><span class="o">.</span><span class="n">numElectron</span> <span class="o">!=</span> <span class="n">resObj</span><span class="o">.</span><span class="n">totalValence</span><span class="p">:</span>
    <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%g</span><span class="s"> == numElectron != totalValence == </span><span class="si">%g</span><span class="s">&#39;</span> \
      <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">numElectron</span><span class="p">,</span> <span class="n">resObj</span><span class="o">.</span><span class="n">totalValence</span><span class="p">,))</span>

  <span class="c"># atomMrr = map containing array.  Example:</span>
  <span class="c">#   _dimLens: [5]</span>
  <span class="c">#   _dimNames: [&#39;ion&#39;]</span>
  <span class="c">#   _fieldNames: [&#39;element&#39; &#39;atomtype&#39;]</span>
  <span class="c">#   _fieldTypes: [&#39;s&#39; &#39;i&#39;]</span>
  <span class="c">#   element: [&#39;C &#39; &#39;Fe&#39; &#39;Fe&#39; &#39;Fe&#39; &#39;Fe&#39;]</span>
  <span class="c">#   atomtype: [1 2 2 2 2]</span>

  <span class="n">atomMrr</span> <span class="o">=</span> <span class="n">getArrayByPath</span><span class="p">(</span>
    <span class="n">bugLev</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="s">&#39;atominfo/array[@name=</span><span class="se">\&#39;</span><span class="s">atoms</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">atomMrr:&#39;</span>
    <span class="n">printMrr</span><span class="p">(</span> <span class="n">atomMrr</span><span class="p">)</span>

  <span class="n">resObj</span><span class="o">.</span><span class="n">atomNames</span> <span class="o">=</span> <span class="n">atomMrr</span><span class="p">[</span><span class="s">&#39;element&#39;</span><span class="p">]</span>
  <span class="n">natom</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">atomNames</span><span class="p">)</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">atomMasses_amu</span> <span class="o">=</span> <span class="n">natom</span> <span class="o">*</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">atomValences</span> <span class="o">=</span> <span class="n">natom</span> <span class="o">*</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">atomPseudos</span> <span class="o">=</span> <span class="n">natom</span> <span class="o">*</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span>
  <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">natom</span><span class="p">):</span>
    <span class="n">ix</span> <span class="o">=</span> <span class="n">atomMrr</span><span class="p">[</span><span class="s">&#39;atomtype&#39;</span><span class="p">][</span><span class="n">ii</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>       <span class="c"># change to origin 0</span>
    <span class="k">if</span> <span class="n">resObj</span><span class="o">.</span><span class="n">atomNames</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">!=</span> <span class="n">resObj</span><span class="o">.</span><span class="n">typeNames</span><span class="p">[</span><span class="n">ix</span><span class="p">]:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;name mismatch&#39;</span><span class="p">)</span>
    <span class="n">resObj</span><span class="o">.</span><span class="n">atomMasses_amu</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>   <span class="o">=</span> <span class="n">resObj</span><span class="o">.</span><span class="n">typeMasses_amu</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span>
    <span class="n">resObj</span><span class="o">.</span><span class="n">atomValences</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">resObj</span><span class="o">.</span><span class="n">typeValences</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span>
    <span class="n">resObj</span><span class="o">.</span><span class="n">atomPseudos</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">resObj</span><span class="o">.</span><span class="n">typePseudos</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;atomNames: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">atomNames</span><span class="p">,)</span>
    <span class="k">print</span> <span class="s">&#39;atomMasses_amu: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">atomMasses_amu</span><span class="p">,)</span>
    <span class="k">print</span> <span class="s">&#39;atomValences: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">atomValences</span><span class="p">,)</span>
    <span class="k">print</span> <span class="s">&#39;atomPseudos: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">atomPseudos</span><span class="p">,)</span>

  <span class="c"># Make sure typenames are in alphabetic order</span>
  <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">typeNames</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">resObj</span><span class="o">.</span><span class="n">typeNames</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">resObj</span><span class="o">.</span><span class="n">typeNames</span><span class="p">[</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
      <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;typeNames not in order&#39;</span><span class="p">)</span>

  <span class="c"># Make sure atomnames are in alphabetic order</span>
  <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">atomNames</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">resObj</span><span class="o">.</span><span class="n">atomNames</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">resObj</span><span class="o">.</span><span class="n">atomNames</span><span class="p">[</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
      <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;atomNames not in order&#39;</span><span class="p">)</span>

  <span class="c"># Future: if need be:</span>
  <span class="c">## Use ixs to sort parallel arrays typenames, typenums, etc,</span>
  <span class="c">## by typenames alphabetic order</span>
  <span class="c">#ixs = range( tlen)</span>
  <span class="c">#def sortFunc( ia, ib):</span>
  <span class="c">#  return cmp( tnames[ia], tnames[ib])</span>
  <span class="c">#ixs.sort( sortFunc)</span>

  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">===== initial structure =====</span><span class="se">\n</span><span class="s">&#39;</span>

  <span class="c"># Initial structure</span>
  <span class="c"># PyLada: vasp/extract/base.py: initial_structure()</span>
  <span class="c"># OUTCAR: uses the appended INITIAL STRUCTURE section.</span>
  <span class="n">lst</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span>
    <span class="s">&#39;structure[@name=</span><span class="se">\&#39;</span><span class="s">initialpos</span><span class="se">\&#39;</span><span class="s">]/crystal/varray[@name=</span><span class="se">\&#39;</span><span class="s">basis</span><span class="se">\&#39;</span><span class="s">]/v&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;len(lst) a:&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>

  <span class="c"># initial_structure</span>
  <span class="c"># POSCAR specifies each basis vector as one row.</span>
  <span class="c"># So does vasprun.xml.</span>
  <span class="c"># But PyLada&#39;s structure.cell is the transpose: each basis vec is a column.</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">initialBasisMat</span> <span class="o">=</span> <span class="n">getRawArray</span><span class="p">(</span>
    <span class="n">root</span><span class="p">,</span>
    <span class="s">&#39;structure[@name=</span><span class="se">\&#39;</span><span class="s">initialpos</span><span class="se">\&#39;</span><span class="s">]/crystal/varray[@name=</span><span class="se">\&#39;</span><span class="s">basis</span><span class="se">\&#39;</span><span class="s">]/v&#39;</span><span class="p">,</span>
    <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">initialRecipBasisMat</span> <span class="o">=</span> <span class="n">getRawArray</span><span class="p">(</span>
    <span class="n">root</span><span class="p">,</span>
    <span class="s">&#39;structure[@name=</span><span class="se">\&#39;</span><span class="s">initialpos</span><span class="se">\&#39;</span><span class="s">]/crystal/varray[@name=</span><span class="se">\&#39;</span><span class="s">rec_basis</span><span class="se">\&#39;</span><span class="s">]/v&#39;</span><span class="p">,</span>
    <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">initialDirectPosMat</span> <span class="o">=</span> <span class="n">getRawArray</span><span class="p">(</span>
    <span class="n">root</span><span class="p">,</span>
    <span class="s">&#39;structure[@name=</span><span class="se">\&#39;</span><span class="s">initialpos</span><span class="se">\&#39;</span><span class="s">]/varray[@name=</span><span class="se">\&#39;</span><span class="s">positions</span><span class="se">\&#39;</span><span class="s">]/v&#39;</span><span class="p">,</span>
    <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>    <span class="c"># xxx nrow should be natom</span>

  <span class="n">resObj</span><span class="o">.</span><span class="n">initialCartesianPosMat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
    <span class="n">resObj</span><span class="o">.</span><span class="n">initialDirectPosMat</span><span class="p">,</span> <span class="n">resObj</span><span class="o">.</span><span class="n">initialBasisMat</span><span class="p">)</span>
  <span class="c"># xxx mult by scale factor?</span>

  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;initialBasisMat:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">initialBasisMat</span><span class="p">),)</span>
    <span class="k">print</span> <span class="s">&#39;initialRecipBasisMat:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">initialRecipBasisMat</span><span class="p">),)</span>
    <span class="k">print</span> <span class="s">&#39;initialDirectPosMat:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">initialDirectPosMat</span><span class="p">),)</span>
    <span class="k">print</span> <span class="s">&#39;initialCartesianPosMat:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">initialCartesianPosMat</span><span class="p">),)</span>
    <span class="k">print</span> <span class="s">&#39;Check inverse: dot(basis,recip):</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> \
      <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">initialBasisMat</span><span class="p">,</span> <span class="n">resObj</span><span class="o">.</span><span class="n">initialRecipBasisMat</span><span class="p">)),)</span>
    <span class="k">print</span> <span class="s">&#39;Check inverse: dot(recip,basis):</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> \
      <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">initialRecipBasisMat</span><span class="p">,</span> <span class="n">resObj</span><span class="o">.</span><span class="n">initialBasisMat</span><span class="p">)),)</span>



  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">===== final structure =====</span><span class="se">\n</span><span class="s">&#39;</span>

  <span class="c"># structure == final pos</span>
  <span class="c"># POSCAR specifies each basis vector as one row.</span>
  <span class="c"># So does vasprun.xml.</span>
  <span class="c"># But PyLada&#39;s structure.cell is the transpose: each basis vec is a column.</span>
  <span class="c"># PyLada reads the catted CONTCAR.</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">finalBasisMat</span> <span class="o">=</span> <span class="n">getRawArray</span><span class="p">(</span>
    <span class="n">root</span><span class="p">,</span>
    <span class="s">&#39;structure[@name=</span><span class="se">\&#39;</span><span class="s">finalpos</span><span class="se">\&#39;</span><span class="s">]/crystal/varray[@name=</span><span class="se">\&#39;</span><span class="s">basis</span><span class="se">\&#39;</span><span class="s">]/v&#39;</span><span class="p">,</span>
    <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">finalRecipBasisMat</span> <span class="o">=</span> <span class="n">getRawArray</span><span class="p">(</span>
    <span class="n">root</span><span class="p">,</span>
    <span class="s">&#39;structure[@name=</span><span class="se">\&#39;</span><span class="s">finalpos</span><span class="se">\&#39;</span><span class="s">]/crystal/varray[@name=</span><span class="se">\&#39;</span><span class="s">rec_basis</span><span class="se">\&#39;</span><span class="s">]/v&#39;</span><span class="p">,</span>
    <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">finalDirectPosMat</span> <span class="o">=</span> <span class="n">getRawArray</span><span class="p">(</span>
    <span class="n">root</span><span class="p">,</span>
    <span class="s">&#39;structure[@name=</span><span class="se">\&#39;</span><span class="s">finalpos</span><span class="se">\&#39;</span><span class="s">]/varray[@name=</span><span class="se">\&#39;</span><span class="s">positions</span><span class="se">\&#39;</span><span class="s">]/v&#39;</span><span class="p">,</span>
    <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>    <span class="c"># xxx nrow should be natom</span>

  <span class="n">resObj</span><span class="o">.</span><span class="n">finalCartesianPosMat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
    <span class="n">resObj</span><span class="o">.</span><span class="n">finalDirectPosMat</span><span class="p">,</span> <span class="n">resObj</span><span class="o">.</span><span class="n">finalBasisMat</span><span class="p">)</span>
  <span class="c"># xxx mult by scale factor?</span>

  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;finalBasisMat:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">finalBasisMat</span><span class="p">),)</span>
    <span class="k">print</span> <span class="s">&#39;finalRecipBasisMat:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">finalRecipBasisMat</span><span class="p">),)</span>
    <span class="k">print</span> <span class="s">&#39;finalDirectPosMat:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">finalDirectPosMat</span><span class="p">),)</span>
    <span class="k">print</span> <span class="s">&#39;finalCartesianPosMat:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">finalCartesianPosMat</span><span class="p">),)</span>
    <span class="k">print</span> <span class="s">&#39;Check inverse: dot(basis,recip):</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> \
      <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">finalBasisMat</span><span class="p">,</span> <span class="n">resObj</span><span class="o">.</span><span class="n">finalRecipBasisMat</span><span class="p">)),)</span>
    <span class="k">print</span> <span class="s">&#39;Check inverse: dot(recip,basis):</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> \
      <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">finalRecipBasisMat</span><span class="p">,</span> <span class="n">resObj</span><span class="o">.</span><span class="n">finalBasisMat</span><span class="p">)),)</span>



  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">===== kpoints =====</span><span class="se">\n</span><span class="s">&#39;</span>

  <span class="c"># kpoint coordinates.</span>
  <span class="c"># Not in PyLada?</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">kpointRecipSpaceFracCoords</span> <span class="o">=</span> <span class="n">getRawArray</span><span class="p">(</span>
    <span class="n">root</span><span class="p">,</span> <span class="s">&#39;kpoints/varray[@name=</span><span class="se">\&#39;</span><span class="s">kpointlist</span><span class="se">\&#39;</span><span class="s">]/v&#39;</span><span class="p">,</span>
    <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">numKpoint</span> <span class="o">=</span> <span class="n">resObj</span><span class="o">.</span><span class="n">kpointRecipSpaceFracCoords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

  <span class="n">resObj</span><span class="o">.</span><span class="n">kpointRecipSpaceCartCoords</span> \
    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">kpointRecipSpaceFracCoords</span><span class="p">,</span> <span class="n">resObj</span><span class="o">.</span><span class="n">initialRecipBasisMat</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;numKpoint: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">numKpoint</span><span class="p">,)</span>
    <span class="k">print</span> <span class="s">&#39;kpointRecipSpaceFracCoords:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> \
      <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">kpointRecipSpaceFracCoords</span><span class="p">),)</span>
    <span class="k">print</span> <span class="s">&#39;kpointRecipSpaceCartCoords:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> \
      <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">kpointRecipSpaceCartCoords</span><span class="p">),)</span>

  <span class="c"># This is what PyLada calls multiplicity.</span>
  <span class="c"># The only diff is the scaling.</span>
  <span class="c">#   sum( Pylada multiplicity) = numKpoint</span>
  <span class="c">#   sum( our kpointWeights) = 1.0</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">kpointWeights</span> <span class="o">=</span> <span class="n">getRawArray</span><span class="p">(</span>
    <span class="n">root</span><span class="p">,</span> <span class="s">&#39;kpoints/varray[@name=</span><span class="se">\&#39;</span><span class="s">weights</span><span class="se">\&#39;</span><span class="s">]/v&#39;</span><span class="p">,</span>
    <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">kpointWeights</span> <span class="o">=</span> <span class="n">resObj</span><span class="o">.</span><span class="n">kpointWeights</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>   <span class="c"># Only 1 col in 2d array</span>
  <span class="k">if</span> <span class="n">resObj</span><span class="o">.</span><span class="n">kpointWeights</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">resObj</span><span class="o">.</span><span class="n">numKpoint</span><span class="p">:</span>
    <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;numKpoint mismatch&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;kpointWeights:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">kpointWeights</span><span class="p">),)</span>
    <span class="k">print</span> <span class="s">&#39;kpointWeights sum: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">kpointWeights</span><span class="p">),)</span>



  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">===== final volume and density =====</span><span class="se">\n</span><span class="s">&#39;</span>

  <span class="c"># volume, Angstrom^3</span>
  <span class="n">volScale</span> <span class="o">=</span> <span class="mf">1.0</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">finalVolumeCalc_ang3</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span>
    <span class="n">volScale</span> <span class="o">*</span> <span class="n">resObj</span><span class="o">.</span><span class="n">finalBasisMat</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;finalVolumeCalc_ang3: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">finalVolumeCalc_ang3</span><span class="p">,)</span>

  <span class="n">resObj</span><span class="o">.</span><span class="n">finalVolumeVasp_ang3</span> <span class="o">=</span> <span class="n">getScalar</span><span class="p">(</span>
    <span class="n">root</span><span class="p">,</span> <span class="s">&#39;structure[@name=</span><span class="se">\&#39;</span><span class="s">finalpos</span><span class="se">\&#39;</span><span class="s">]/crystal/i[@name=</span><span class="se">\&#39;</span><span class="s">volume</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;finalVolumeVasp_ang3: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">finalVolumeVasp_ang3</span><span class="p">,)</span>

  <span class="c"># reciprocal space volume, * (2*pi)**3</span>
  <span class="n">invMat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span> <span class="n">volScale</span> <span class="o">*</span> <span class="n">resObj</span><span class="o">.</span><span class="n">finalBasisMat</span><span class="p">)</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">recVolumeCalc</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span> <span class="n">invMat</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;recVolumeCalc: origMat:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> \
      <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">volScale</span> <span class="o">*</span> <span class="n">resObj</span><span class="o">.</span><span class="n">finalBasisMat</span><span class="p">),)</span>
    <span class="k">print</span> <span class="s">&#39;recVolumeCalc: invMat:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">invMat</span><span class="p">),)</span>
    <span class="k">print</span> <span class="s">&#39;recVolumeCalc: det:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span> <span class="n">invMat</span><span class="p">)),)</span>
    <span class="k">print</span> <span class="s">&#39;recVolumeCalc: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">recVolumeCalc</span><span class="p">,)</span>

  <span class="c"># Density</span>
  <span class="c"># xxx better: get atomic weights from periodic table</span>
  <span class="n">volCm</span> <span class="o">=</span> <span class="n">resObj</span><span class="o">.</span><span class="n">finalVolumeCalc_ang3</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.e8</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span>    <span class="c"># 10**8 Angstrom per cm</span>
  <span class="n">totMass</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">atomTypeMrr</span><span class="p">[</span><span class="s">&#39;atomspertype&#39;</span><span class="p">],</span> <span class="n">atomTypeMrr</span><span class="p">[</span><span class="s">&#39;mass&#39;</span><span class="p">])</span>
  <span class="n">totMassGm</span> <span class="o">=</span> <span class="n">totMass</span> <span class="o">*</span>  <span class="mf">1.660538921e-24</span>        <span class="c">#  1.660538921e-24 g / amu</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">density_g_cm3</span> <span class="o">=</span> <span class="n">totMassGm</span> <span class="o">/</span> <span class="n">volCm</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;volCm: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">volCm</span><span class="p">,)</span>
    <span class="k">print</span> <span class="s">&#39;totMassGm: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">totMassGm</span><span class="p">,)</span>
    <span class="k">print</span> <span class="s">&#39;density_g_cm3: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">density_g_cm3</span><span class="p">,)</span>


  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">===== last calc forces =====</span><span class="se">\n</span><span class="s">&#39;</span>

  <span class="n">resObj</span><span class="o">.</span><span class="n">finalForceMat_ev_ang</span> <span class="o">=</span> <span class="n">getRawArray</span><span class="p">(</span>
    <span class="n">root</span><span class="p">,</span> <span class="s">&#39;calculation[last()]/varray[@name=</span><span class="se">\&#39;</span><span class="s">forces</span><span class="se">\&#39;</span><span class="s">]/v&#39;</span><span class="p">,</span>
    <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;finalForceMat_ev_ang:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">finalForceMat_ev_ang</span><span class="p">),)</span>

  <span class="c"># Get stress</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">finalStressMat_kbar</span> <span class="o">=</span> <span class="n">getRawArray</span><span class="p">(</span>
    <span class="n">root</span><span class="p">,</span> <span class="s">&#39;calculation[last()]/varray[@name=</span><span class="se">\&#39;</span><span class="s">stress</span><span class="se">\&#39;</span><span class="s">]/v&#39;</span><span class="p">,</span>
    <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;finalStressMat_kbar:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">finalStressMat_kbar</span><span class="p">),)</span>

  <span class="c"># Calc pressure</span>
  <span class="c"># xxx Caution: we do not include the non-diag terms in:</span>
  <span class="c">#   VASP: force.F: FORCE_AND_STRESS: line 1410:</span>
  <span class="c">#     PRESS=(TSIF(1,1)+TSIF(2,2)+TSIF(3,3))/3._q &amp;</span>
  <span class="c">#        &amp;      -DYN%PSTRESS/(EVTOJ*1E22_q)*LATT_CUR%OMEGA</span>
  <span class="n">diag</span> <span class="o">=</span> <span class="p">[</span><span class="n">resObj</span><span class="o">.</span><span class="n">finalStressMat_kbar</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">ii</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">finalPressure_kbar</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span> <span class="n">diag</span><span class="p">)</span> <span class="o">/</span> <span class="mf">3.0</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;finalPressure_kbar: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">finalPressure_kbar</span><span class="p">,)</span>


  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">===== eigenvalues and occupancies =====</span><span class="se">\n</span><span class="s">&#39;</span>

  <span class="c"># PyLada: eigenvalues</span>
  <span class="n">eigenMrr</span> <span class="o">=</span> <span class="n">getArrayByPath</span><span class="p">(</span>
    <span class="n">bugLev</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="s">&#39;calculation[last()]/eigenvalues/array&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">eigenMrr beg =====:&#39;</span>
    <span class="n">printMrr</span><span class="p">(</span> <span class="n">eigenMrr</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">eigenMrr end =====:&#39;</span>
    <span class="k">for</span> <span class="n">isp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">numSpin</span><span class="p">):</span>
      <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">eigenMrr: eigene[isp=</span><span class="si">%d</span><span class="s">][0]</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> \
        <span class="o">%</span> <span class="p">(</span><span class="n">isp</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">eigenMrr</span><span class="p">[</span><span class="s">&#39;eigene&#39;</span><span class="p">][</span><span class="n">isp</span><span class="p">][</span><span class="mi">0</span><span class="p">]),)</span>
      <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">eigenMrr: occ[isp=</span><span class="si">%d</span><span class="s">][0]</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> \
        <span class="o">%</span> <span class="p">(</span><span class="n">isp</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">eigenMrr</span><span class="p">[</span><span class="s">&#39;occ&#39;</span><span class="p">][</span><span class="n">isp</span><span class="p">][</span><span class="mi">0</span><span class="p">]),)</span>

  <span class="n">shp</span> <span class="o">=</span> <span class="n">eigenMrr</span><span class="p">[</span><span class="s">&#39;_dimLens&#39;</span><span class="p">]</span>
  <span class="k">if</span> <span class="n">shp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">resObj</span><span class="o">.</span><span class="n">numSpin</span><span class="p">:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;numSpin mismatch&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">shp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">resObj</span><span class="o">.</span><span class="n">numKpoint</span><span class="p">:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;numKpoint mismatch&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">shp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="n">prmNumBand</span><span class="p">:</span>     <span class="c"># see caution at prmNumBand, above</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;numBand mismatch: prm: </span><span class="si">%d</span><span class="s">  shape: </span><span class="si">%d</span><span class="s">  inXml: </span><span class="si">%s</span><span class="s">&#39;</span> \
      <span class="o">%</span> <span class="p">(</span><span class="n">prmNumBand</span><span class="p">,</span> <span class="n">shp</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">inXml</span><span class="p">,))</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">numBand</span> <span class="o">=</span> <span class="n">shp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

  <span class="n">resObj</span><span class="o">.</span><span class="n">eigenMat</span> <span class="o">=</span> <span class="n">eigenMrr</span><span class="p">[</span><span class="s">&#39;eigene&#39;</span><span class="p">]</span>
  <span class="c"># Caution: for non-magnetic, OUTCAR occMat = 2 while vasprun.xml = 1.</span>
  <span class="c"># For magnetic, OUTCAR and vasprun.xml both have 1.</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">occMat</span> <span class="o">=</span> <span class="n">eigenMrr</span><span class="p">[</span><span class="s">&#39;occ&#39;</span><span class="p">]</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;resObj.eigenMat.shape: &#39;</span><span class="p">,</span> <span class="n">resObj</span><span class="o">.</span><span class="n">eigenMat</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">print</span> <span class="s">&#39;resObj.occMat.shape: &#39;</span><span class="p">,</span> <span class="n">resObj</span><span class="o">.</span><span class="n">occMat</span><span class="o">.</span><span class="n">shape</span>
  
  <span class="c"># Compare projected and standard eigenvalues</span>
  <span class="n">getProjected</span> <span class="o">=</span> <span class="bp">False</span>
  <span class="k">if</span> <span class="n">getProjected</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">isp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">numSpin</span><span class="p">):</span>
      <span class="n">projEigenMrr</span> <span class="o">=</span> <span class="n">getArrayByPath</span><span class="p">(</span>
        <span class="n">bugLev</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="s">&#39;calculation[last()]/projected/eigenvalues/array&#39;</span><span class="p">)</span>
      
      <span class="c"># eigs and projected eigs are identical</span>
      <span class="n">eigs</span> <span class="o">=</span> <span class="n">resObj</span><span class="o">.</span><span class="n">eigenMrr</span><span class="p">[</span><span class="s">&#39;eigene&#39;</span><span class="p">][</span><span class="n">isp</span><span class="p">]</span>
      <span class="n">peigs</span> <span class="o">=</span> <span class="n">projEigenMrr</span><span class="p">[</span><span class="s">&#39;eigene&#39;</span><span class="p">][</span><span class="n">isp</span><span class="p">]</span>
      <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;Compare iegs, peigs for isp: </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">isp</span><span class="p">,)</span>
        <span class="k">print</span> <span class="s">&#39;  eigs.shape:  &#39;</span><span class="p">,</span> <span class="n">eigs</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">print</span> <span class="s">&#39;  peigs.shape: &#39;</span><span class="p">,</span> <span class="n">peigs</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">print</span> <span class="s">&#39;  eigs[0,:]: &#39;</span><span class="p">,</span> <span class="n">eigs</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
        <span class="k">print</span> <span class="s">&#39;  peigs[0,:]: &#39;</span><span class="p">,</span> <span class="n">peigs</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
        <span class="k">print</span> <span class="s">&#39;  Diff projeigs - eigs: max maxabs: </span><span class="si">%g</span><span class="s">&#39;</span> \
          <span class="o">%</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span> <span class="nb">map</span><span class="p">(</span> <span class="nb">max</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">peigs</span> <span class="o">-</span> <span class="n">eigs</span><span class="p">))),)</span>

      <span class="c"># occs and projected occs are identical</span>
      <span class="n">occs</span> <span class="o">=</span> <span class="n">resObj</span><span class="o">.</span><span class="n">eigenMrr</span><span class="p">[</span><span class="s">&#39;occ&#39;</span><span class="p">][</span><span class="n">isp</span><span class="p">]</span>
      <span class="n">poccs</span> <span class="o">=</span> <span class="n">projEigenMrr</span><span class="p">[</span><span class="s">&#39;occ&#39;</span><span class="p">][</span><span class="n">isp</span><span class="p">]</span>
      <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;Compare occs, poccs for isp: </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">isp</span><span class="p">,)</span>
        <span class="k">print</span> <span class="s">&#39;  occs.shape:  &#39;</span><span class="p">,</span> <span class="n">occs</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">print</span> <span class="s">&#39;  poccs.shape: &#39;</span><span class="p">,</span> <span class="n">poccs</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">print</span> <span class="s">&#39;  occs[0,:]: &#39;</span><span class="p">,</span> <span class="n">occs</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
        <span class="k">print</span> <span class="s">&#39;  poccs[0,:]: &#39;</span><span class="p">,</span> <span class="n">poccs</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
        <span class="k">print</span> <span class="s">&#39;  Diff projoccs - occs: max maxabs: </span><span class="si">%g</span><span class="s">&#39;</span> \
          <span class="o">%</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span> <span class="nb">map</span><span class="p">(</span> <span class="nb">max</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">poccs</span> <span class="o">-</span> <span class="n">occs</span><span class="p">))),)</span>

  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">===== misc junk =====</span><span class="se">\n</span><span class="s">&#39;</span>

  <span class="c"># PyLada: vasp/extract/base.py: is_gw()</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">isGw</span> <span class="o">=</span> <span class="bp">False</span>
  <span class="k">if</span> <span class="n">resObj</span><span class="o">.</span><span class="n">algo</span> <span class="ow">in</span>  <span class="p">[</span><span class="s">&#39;gw&#39;</span><span class="p">,</span> <span class="s">&#39;gw0&#39;</span><span class="p">,</span> <span class="s">&#39;chi&#39;</span><span class="p">,</span> <span class="s">&#39;scgw&#39;</span><span class="p">,</span> <span class="s">&#39;scgw0&#39;</span><span class="p">]:</span> <span class="n">resObj</span><span class="o">.</span><span class="n">isGw</span> <span class="o">=</span> <span class="bp">True</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;isGw: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">isGw</span><span class="p">,)</span>

  <span class="c"># PyLada: vasp/extract/base.py: is_dft()</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">isDft</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">resObj</span><span class="o">.</span><span class="n">isGw</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;isDft: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">isDft</span><span class="p">,)</span>

  <span class="c"># functional: comes from appended FUNCTIONAL.</span>

  <span class="c"># success: look for final section</span>
  <span class="c">#   General timing and accounting informations for this job:</span>

  <span class="c"># xxx skip: Hubbard / NLEP</span>

  

  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">===== energy, efermi0 =====</span><span class="se">\n</span><span class="s">&#39;</span>

  <span class="n">resObj</span><span class="o">.</span><span class="n">energyNoEntrp</span> <span class="o">=</span> <span class="n">getScalar</span><span class="p">(</span>
    <span class="n">root</span><span class="p">,</span> <span class="s">&#39;calculation[last()]/energy/i[@name=</span><span class="se">\&#39;</span><span class="s">e_wo_entrp</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

  <span class="c"># efermi0</span>
  <span class="c"># PyLada uses an algorithm to compare the sum of occupancies</span>
  <span class="c"># to the valence.</span>
  <span class="c"># We get it from the xml file here.</span>
  <span class="c">#   PyLada: 5.8574</span>
  <span class="c">#   XML:    5.93253</span>

  <span class="n">resObj</span><span class="o">.</span><span class="n">efermi0</span> <span class="o">=</span> <span class="n">getScalar</span><span class="p">(</span>
    <span class="n">root</span><span class="p">,</span> <span class="s">&#39;calculation[last()]/dos/i[@name=</span><span class="se">\&#39;</span><span class="s">efermi</span><span class="se">\&#39;</span><span class="s">]&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;efermi0: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">efermi0</span><span class="p">,)</span>


  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">===== cbMin, vbMax, bandgap =====</span><span class="se">\n</span><span class="s">&#39;</span>

  <span class="c"># Find cbm = min of eigs &gt;  efermi0</span>
  <span class="c"># Find vbm = max of eigs &lt;= efermi0</span>

  <span class="n">cbms</span> <span class="o">=</span> <span class="n">resObj</span><span class="o">.</span><span class="n">numSpin</span> <span class="o">*</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span>
  <span class="n">vbms</span> <span class="o">=</span> <span class="n">resObj</span><span class="o">.</span><span class="n">numSpin</span> <span class="o">*</span> <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span>
  <span class="n">cbmKpis</span> <span class="o">=</span> <span class="n">resObj</span><span class="o">.</span><span class="n">numSpin</span> <span class="o">*</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span>
  <span class="n">vbmKpis</span> <span class="o">=</span> <span class="n">resObj</span><span class="o">.</span><span class="n">numSpin</span> <span class="o">*</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span>

  <span class="k">for</span> <span class="n">isp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">numSpin</span><span class="p">):</span>
    <span class="n">eigs</span> <span class="o">=</span> <span class="n">resObj</span><span class="o">.</span><span class="n">eigenMat</span><span class="p">[</span><span class="n">isp</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">ikp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">numKpoint</span><span class="p">):</span>
      <span class="k">for</span> <span class="n">iband</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">numBand</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">eigs</span><span class="p">[</span><span class="n">ikp</span><span class="p">][</span><span class="n">iband</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">resObj</span><span class="o">.</span><span class="n">efermi0</span><span class="p">:</span>
          <span class="n">cbms</span><span class="p">[</span><span class="n">isp</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span> <span class="n">cbms</span><span class="p">[</span><span class="n">isp</span><span class="p">],</span> <span class="n">val</span><span class="p">)</span>
          <span class="n">cbmKpis</span><span class="p">[</span><span class="n">isp</span><span class="p">]</span> <span class="o">=</span> <span class="n">ikp</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;=</span> <span class="n">resObj</span><span class="o">.</span><span class="n">efermi0</span><span class="p">:</span>
          <span class="n">vbms</span><span class="p">[</span><span class="n">isp</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span> <span class="n">vbms</span><span class="p">[</span><span class="n">isp</span><span class="p">],</span> <span class="n">val</span><span class="p">)</span>
          <span class="n">vbmKpis</span><span class="p">[</span><span class="n">isp</span><span class="p">]</span> <span class="o">=</span> <span class="n">ikp</span>

  <span class="n">cbms</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span> <span class="nb">float</span><span class="p">,</span> <span class="n">cbms</span><span class="p">)</span>     <span class="c"># change type from numpy.float64 to float</span>
  <span class="n">vbms</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span> <span class="nb">float</span><span class="p">,</span> <span class="n">vbms</span><span class="p">)</span>     <span class="c"># change type from numpy.float64 to float</span>

  <span class="n">resObj</span><span class="o">.</span><span class="n">cbms</span> <span class="o">=</span> <span class="n">cbms</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">vbms</span> <span class="o">=</span> <span class="n">vbms</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">cbmKpis</span> <span class="o">=</span> <span class="n">cbmKpis</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">vbmKpis</span> <span class="o">=</span> <span class="n">vbmKpis</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">cbMin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span> <span class="n">cbms</span><span class="p">)</span>       <span class="c"># This is PyLada&#39;s cbm</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">vbMax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span> <span class="n">vbms</span><span class="p">)</span>       <span class="c"># This is PyLada&#39;s vbm</span>

  <span class="n">resObj</span><span class="o">.</span><span class="n">bandgaps</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">cbms</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">-</span> <span class="n">vbms</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">numSpin</span><span class="p">)]</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">bandgapa</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span> <span class="n">resObj</span><span class="o">.</span><span class="n">bandgaps</span><span class="p">)</span>
  <span class="n">resObj</span><span class="o">.</span><span class="n">bandgap</span>  <span class="o">=</span> <span class="n">resObj</span><span class="o">.</span><span class="n">cbMin</span> <span class="o">-</span> <span class="n">resObj</span><span class="o">.</span><span class="n">vbMax</span>   <span class="c"># This is PyLada version</span>

  <span class="k">if</span> <span class="n">bugLev</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">&#39;cbmKpis: </span><span class="si">%s</span><span class="s">  cbms: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">cbmKpis</span><span class="p">,</span> <span class="n">cbms</span><span class="p">,)</span>
    <span class="k">print</span> <span class="s">&#39;vbmKpis: </span><span class="si">%s</span><span class="s">  vbms: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">vbmKpis</span><span class="p">,</span> <span class="n">vbms</span><span class="p">,)</span>
    <span class="k">print</span> <span class="s">&#39;cbMin: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">cbMin</span><span class="p">,)</span>
    <span class="k">print</span> <span class="s">&#39;vbMax: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">vbMax</span><span class="p">,)</span>
    <span class="k">print</span> <span class="s">&#39;bandgaps: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">bandgaps</span><span class="p">,)</span>
    <span class="k">print</span> <span class="s">&#39;bandgapa: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">bandgapa</span><span class="p">,)</span>
    <span class="k">print</span> <span class="s">&#39;bandgap:  </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">resObj</span><span class="o">.</span><span class="n">bandgap</span><span class="p">,)</span>



  <span class="c"># xxx</span>
  <span class="c"># delta between cbmIndex, vbmIndex</span>
  <span class="c"># print kpoints coords.  which is gamma, etc?</span>
  <span class="c"># is any of frasier med exp?</span>


  <span class="k">return</span>


  <span class="c">########################### End of parseXml ###############################</span>


  <span class="c"># The following code was used for initial testing,</span>
  <span class="c"># and who knows, someday may be useful again.</span>

  <span class="c">#print &#39;\n&#39;</span>
  <span class="c">#print &#39;\ntesta:&#39;</span>
  <span class="c">#lst = root.findall(&#39;kpoints/generation/v[@name=\&#39;genvec2\&#39;]&#39;)</span>
  <span class="c">#amat = []</span>
  <span class="c">#for ele in lst:</span>
  <span class="c">#  text = ele.text</span>
  <span class="c">#  print &#39;  ele.text: %s&#39; % (text,)</span>
  <span class="c">#  toks = text.split()</span>
  <span class="c">#  vals = map( float, toks)</span>
  <span class="c">#  amat.append( vals)</span>
  <span class="c">#print &#39;amat: %s&#39; % (amat,)</span>

  <span class="c">#amat = np.array( amat, dtype=float)</span>
  <span class="c">#print &#39;amat:\n%s&#39; % (amat,)</span>

  <span class="c">#vec = getVec( root, &#39;kpoints/generation/v[@name=\&#39;genvec2\&#39;]&#39;, 0, 0, float)</span>
  <span class="c">#print &#39;vec:\n%s&#39; % (vec,)</span>

  <span class="c">#amat = getRawArray( root, &#39;kpoints/generation/v&#39;, 0, 0, float)</span>
  <span class="c">#print &#39;amat:\n%s&#39; % (amat,)</span>

  <span class="c">#calcNodes = root.findall(&#39;calculation&#39;)</span>
  <span class="c">#print &#39;\nlen(calcNodes): %d&#39; % (len(calcNodes,))</span>

  <span class="c">## pairs: (itot, en_wo_entrp) for the energy of each scstep</span>
  <span class="c">#scstep_withouts = []</span>
  <span class="c">## pairs: (itot, en_wo_entrp) for the last energy of each calculation step</span>
  <span class="c">#calcstep_withouts = []</span>

  <span class="c">#basisMats = []</span>
  <span class="c">#recipBasisMats = []</span>
  <span class="c">#posMats = []</span>
  <span class="c">#forceMats = []</span>
  <span class="c">#stressMats = []</span>

  <span class="c">#itot = 0     # index all scsteps, across calculations</span>

  <span class="c">#ncalc = len( calcNodes)</span>
  <span class="c">#for icalc in range( ncalc):</span>
  <span class="c">#  cnode = calcNodes[icalc]</span>
  <span class="c">#  forceMat = getRawArray( cnode, &#39;varray[@name=\&#39;forces\&#39;]/v&#39;, 0, 0, float)</span>
  <span class="c">#  print &#39;\nforceMat for calcNodes[%d]:\n%s&#39; % (icalc, forceMat,)</span>
  <span class="c">#  scNodes = cnode.findall(&#39;scstep&#39;)</span>
  <span class="c">#  print &#39;    len(scNodes): %d&#39; % (len(scNodes,))</span>
  <span class="c">#  for isc in range(len(scNodes)):</span>
  <span class="c">#    snode = scNodes[isc]</span>
  <span class="c">#    sc_e_fr = getScalar( snode, &#39;energy/i[@name=\&#39;e_fr_energy\&#39;]&#39;, float)</span>
  <span class="c">#    sc_e_wo = getScalar( snode, &#39;energy/i[@name=\&#39;e_wo_entrp\&#39;]&#39;, float)</span>
  <span class="c">#    sc_e_0  = getScalar( snode, &#39;energy/i[@name=\&#39;e_0_energy\&#39;]&#39;, float)</span>
  <span class="c">#    print &#39;    scNodes[%d]: sc_e_fr: %g  sc_e_wo: %g  sc_e_0: %g&#39; \</span>
  <span class="c">#      % (isc, sc_e_fr, sc_e_wo, sc_e_0,)</span>

  <span class="c">#    scstep_withouts.append( (itot, sc_e_wo,))</span>
  <span class="c">#    itot += 1</span>

  <span class="c">#  # Structure for this calculation step</span>
  <span class="c">#  strucNodes = cnode.findall(&#39;structure&#39;)</span>
  <span class="c">#  if len(strucNodes) != 1: throwerr(&#39;calc structure not found&#39;)</span>
  <span class="c">#  snode = strucNodes[0]</span>
  <span class="c">#  basisMat = getRawArray(</span>
  <span class="c">#    snode, &#39;crystal/varray[@name=\&#39;basis\&#39;]/v&#39;, 3, 3, float)</span>
  <span class="c">#  recipBasisMat = getRawArray(</span>
  <span class="c">#    snode, &#39;crystal/varray[@name=\&#39;rec_basis\&#39;]/v&#39;, 3, 3, float)</span>
  <span class="c">#  # xxx should be nrow = num atoms</span>
  <span class="c">#  posMat = getRawArray(</span>
  <span class="c">#    snode, &#39;varray[@name=\&#39;positions\&#39;]/v&#39;, 0, 3, float)</span>
  <span class="c">#  print &#39;  Calc final: basisMat:\n%s&#39; % (basisMat,)</span>
  <span class="c">#  print &#39;  Calc final: recipBasisMat:\n%s&#39; % (recipBasisMat,)</span>
  <span class="c">#  print &#39;  Calc final: posMat:\n%s&#39; % (posMat,)</span>
  <span class="c">#  basisMats.append( basisMat)</span>
  <span class="c">#  recipBasisMats.append( recipBasisMat)</span>
  <span class="c">#  posMats.append( posMat)</span>

  <span class="c">#  # Forces for this calculation step</span>
  <span class="c">#  forceNodes = cnode.findall(&#39;varray[@name=\&#39;forces\&#39;]&#39;)</span>
  <span class="c">#  if len(forceNodes) != 1: throwerr(&#39;calc forces not found&#39;)</span>
  <span class="c">#  forceMat = getRawArray( forceNodes[0], &#39;v&#39;, 0, 3, float)</span>
  <span class="c">#  print &#39;  Calc final: forceMat:\n%s&#39; % (forceMat,)</span>
  <span class="c">#  forceMats.append( forceMat)</span>

  <span class="c">#  # Stress for this calculation step</span>
  <span class="c">#  stressNodes = cnode.findall(&#39;varray[@name=\&#39;stress\&#39;]&#39;)</span>
  <span class="c">#  if len(stressNodes) != 1: throwerr(&#39;calc stresses not found&#39;)</span>
  <span class="c">#  stressMat = getRawArray( stressNodes[0], &#39;v&#39;, 3, 3, float)</span>
  <span class="c">#  print &#39;  Calc final: stressMat:\n%s&#39; % (stressMat,)</span>
  <span class="c">#  stressMats.append( stressMat)</span>

  <span class="c">#  # Final energy for this calculation step</span>
  <span class="c">#  enNodes = cnode.findall(&#39;energy&#39;)</span>
  <span class="c">#  if len(enNodes) != 1: throwerr(&#39;calc energy not found&#39;)</span>
  <span class="c">#  enode = enNodes[0]</span>
  <span class="c">#  c_e_fr = getScalar( enode, &#39;i[@name=\&#39;e_fr_energy\&#39;]&#39;, float)</span>
  <span class="c">#  c_e_wo = getScalar( enode, &#39;i[@name=\&#39;e_wo_entrp\&#39;]&#39;, float)</span>
  <span class="c">#  c_e_0  = getScalar( enode, &#39;i[@name=\&#39;e_0_energy\&#39;]&#39;, float)</span>
  <span class="c">#  print &#39;  Calc final: c_e_fr: %g  c_e_wo: %g  c_e_0: %g&#39; \</span>
  <span class="c">#    % (c_e_fr, c_e_wo, c_e_0,)</span>
  <span class="c">#  calcstep_withouts.append( (itot - 1, c_e_wo,))</span>

  <span class="c">#print &#39;&#39;</span>
  <span class="c">#print &#39;scstep_withouts: %s&#39; % (scstep_withouts,)</span>
  <span class="c">#print &#39;&#39;</span>
  <span class="c">#print &#39;calcstep_withouts: %s&#39; % (calcstep_withouts,)</span>

  <span class="c">#scmat = np.array( scstep_withouts, dtype=float)</span>
  <span class="c">#print &#39;&#39;</span>
  <span class="c">#print &#39;scmat:\n%s&#39; % (scmat,)</span>

  <span class="c">#calcmat = np.array( calcstep_withouts, dtype=float)</span>
  <span class="c">#print &#39;&#39;</span>
  <span class="c">#print &#39;calcmat:\n%s&#39; % (calcmat,)</span>


  <span class="c">#print &#39;&#39;</span>
  <span class="c">#print &#39;Investigate DOS&#39;</span>
  <span class="c">#icals = len(calcNodes) - 1</span>
  <span class="c">#cnode = calcNodes[icalc]</span>
  <span class="c">#setNodes = cnode.findall(&#39;dos/total/array/set/set[@comment=\&#39;spin 1\&#39;]&#39;)</span>
  <span class="c">#print &#39;    len(total setNodes): %d&#39; % (len(setNodes),)</span>
  <span class="c">#print &#39;    setNodes[0]: %s&#39; % (setNodes[0],)</span>
  <span class="c">#if len(setNodes) != 1: throwerr(&#39;dos/total not found&#39;)</span>
  <span class="c">#dosTotalMat = getRawArray( setNodes[0], &#39;r&#39;, 0, 0, float)</span>
  <span class="c">#print &#39;&#39;</span>
  <span class="c">#print &#39;type(dosTotalMat): &#39;, type(dosTotalMat)</span>
  <span class="c">#print &#39;dosTotalMat.shape: &#39;, dosTotalMat.shape</span>
  <span class="c">#print &#39;&#39;</span>
  <span class="c">#print &#39;dosTotalMat:\n%s&#39; % (dosTotalMat,)</span>

  <span class="c">#dosPartialMats = []</span>
  <span class="c">#partialSetNodes = cnode.findall(&#39;dos/partial/array/set&#39;)</span>
  <span class="c">#print &#39;    len(partialSetNodes): %d&#39; % (len(partialSetNodes),)</span>
  <span class="c">#if len(partialSetNodes) != 1: throwerr(&#39;dos/partial not found&#39;)</span>
  <span class="c">#partialSet = partialSetNodes[0]</span>

  <span class="c">#ionNodes = partialSet.findall(&#39;set&#39;)</span>
  <span class="c">#print &#39;    len(ionNodes): %d&#39; % (len(ionNodes),)</span>
  <span class="c">## xxx should be nrow = num atoms</span>
  <span class="c">#for ii in range(len(ionNodes)):</span>
  <span class="c">#  dosPartialMat = getRawArray(</span>
  <span class="c">#    ionNodes[ii], &#39;set[@comment=\&#39;spin 1\&#39;]/r&#39;, 0, 0, float)</span>
  <span class="c">#  print &#39;&#39;</span>
  <span class="c">#  print &#39;dosPartialMat %d:&#39; % (ii,)</span>
  <span class="c">#  print &#39;type(dosPartialMat): &#39;, type(dosPartialMat)</span>
  <span class="c">#  print &#39;dosPartialMat.shape: &#39;, dosPartialMat.shape</span>
  <span class="c">#  print &#39;&#39;</span>
  <span class="c">#  print &#39;dosPartialMat:\n%s&#39; % (dosPartialMat,)</span>
  <span class="c">#  dosPartialMats.append( dosPartialMat)</span>

  <span class="c">#print &#39;len(dosPartialMats): %d&#39; % (len(dosPartialMats),)</span>




  <span class="c">#print &#39;\nbasisMats:  len: %d&#39; % (len(basisMats),)</span>
  <span class="c">#for mat in basisMats: print &#39;%s&#39; % (mat,)</span>

  <span class="c">#print &#39;\nrecipBasisMats:  len: %d&#39; % (len(recipBasisMats),)</span>
  <span class="c">#for mat in recipBasisMats: print &#39;%s&#39; % (mat,)</span>

  <span class="c">#print &#39;\nposMats:  len: %d&#39; % (len(posMats),)</span>
  <span class="c">#for mat in posMats: print &#39;%s&#39; % (mat,)</span>

  <span class="c">#print &#39;\nforceMats:  len: %d&#39; % (len(forceMats),)</span>
  <span class="c">#for mat in forceMats: print &#39;%s&#39; % (mat,)</span>

  <span class="c">#print &#39;\nstressMats:  len: %d&#39; % (len(stressMats),)</span>
  <span class="c">#for mat in stressMats: print &#39;%s&#39; % (mat,)</span>

  <span class="c">#basisDeltas = calcMatDeltas( basisMats)</span>
  <span class="c">#recipBasisDeltas = calcMatDeltas( recipBasisMats)</span>
  <span class="c">#posDeltas = calcMatDeltas( posMats)</span>
  <span class="c">#forceDeltas = calcMatDeltas( forceMats)</span>
  <span class="c">#stressDeltas = calcMatDeltas( stressMats)</span>

  <span class="c">#print &#39;basisDeltas: %s&#39; % ( basisDeltas,)</span>
  <span class="c">#print &#39;recipBasisDeltas: %s&#39; % ( recipBasisDeltas,)</span>
  <span class="c">#print &#39;posDeltas: %s&#39; % ( posDeltas,)</span>
  <span class="c">#print &#39;forceDeltas: %s&#39; % ( forceDeltas,)</span>
  <span class="c">#print &#39;stressDeltas: %s&#39; % ( stressDeltas,)</span>


  <span class="c">#import matplotlib</span>
  <span class="c">#matplotlib.use(&#39;tkagg&#39;)</span>
  <span class="c">#import matplotlib.pyplot as plt</span>

  <span class="c">#fig, axes = plt.subplots( 1, 1)</span>
  <span class="c">###ax00 = axes[0,0]</span>
  <span class="c">#ax00 = axes</span>
  <span class="c">#ax00.plot( dosTotalMat[:,0], dosTotalMat[:,1], color=&#39;r&#39;, linestyle=&#39;-&#39;,</span>
  <span class="c">#  marker=None)</span>
  <span class="c">#ax00.set_xlabel(&#39;Energy, eV&#39;)</span>
  <span class="c">#ax00.set_ylabel(&#39;Number of states per unit cell&#39;)</span>
  <span class="c">#ax00.set_title(&#39;Density of states&#39;)</span>
  <span class="c">#ax00.xaxis.grid(color=&#39;lightblue&#39;, linestyle=&#39;solid&#39;)</span>
  <span class="c">#ax00.yaxis.grid(color=&#39;lightblue&#39;, linestyle=&#39;solid&#39;)</span>
  <span class="c">##plt.show()</span>


  <span class="c">##fig, ax = plt.subplots()</span>
  <span class="c">##</span>
  <span class="c">##ax.plot( scmat[:,0], scmat[:,1], &#39;b-&#39;)</span>
  <span class="c">##ax.plot( calcmat[:,0], calcmat[:,1], &#39;bo&#39;)</span>
  <span class="c">##ax.set_ylim( calcmat[-1,1] - 5, calcmat[-1,1] + 5)</span>
  <span class="c">##ax.xaxis.grid(color=&#39;lightblue&#39;, linestyle=&#39;solid&#39;)</span>
  <span class="c">##ax.yaxis.grid(color=&#39;lightblue&#39;, linestyle=&#39;solid&#39;)</span>
  <span class="c">##</span>
  <span class="c">##savefig(&#39;tempa.png&#39;, dpi=100, orientation=&#39;landscape&#39;, papertype=&#39;letter&#39;)</span>
  <span class="c">##</span>
  <span class="c">##plt.show()</span>


  <span class="c">#tnodes = root.findall(&#39;calculation[last()]&#39;)</span>
  <span class="c">#printNode( tnodes[0], 0, 1)</span>

  <span class="c">#tnodes = root.findall(&#39;calculation[last()]/eigenvalues&#39;)</span>
  <span class="c">#printNode( tnodes[0], 0, 1)</span>

  <span class="c">#tnodes = root.findall(&#39;calculation[last()]/eigenvalues/array&#39;)</span>
  <span class="c">#printNode( tnodes[0], 0, 1)</span>

  <span class="c">#res = getArrayByPath(</span>
  <span class="c">#  bugLev, root, &#39;calculation[last()]/eigenvalues/array&#39;)</span>
  <span class="c">#print &#39;\ncalculation[last()]/eigenvalues:\n%s&#39; % (res,)</span>

  <span class="c">#print &#39;\n&#39;</span>

<span class="c">#====================================================================</span>

</div>
<div class="viewcode-block" id="printNode"><a class="viewcode-back" href="../../readVasp.html#nrelmat.readVasp.printNode">[docs]</a><span class="k">def</span> <span class="nf">printNode</span><span class="p">(</span> <span class="n">node</span><span class="p">,</span> <span class="n">curLev</span><span class="p">,</span> <span class="n">maxLev</span><span class="p">):</span>
  <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Recursively prints an XML tree, given an xml.etree.cElementTree node.</span>

<span class="sd">  **Parameters**:</span>

<span class="sd">  * node (xml.etree.ElementTree.Element): The root of the XML tree.</span>
<span class="sd">  * curLev (int): The current recursion level.  Starts at 0 and</span>
<span class="sd">    is incremented for each recursive call.</span>
<span class="sd">  * maxLev (int): The max number of levels to print</span>

<span class="sd">  **Returns**:</span>

<span class="sd">  * None</span>
<span class="sd">  &#39;&#39;&#39;</span>

  <span class="k">if</span> <span class="n">curLev</span> <span class="o">&lt;=</span> <span class="n">maxLev</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">tail</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span> <span class="n">tail</span> <span class="o">=</span> <span class="s">&#39;None&#39;</span>
    <span class="k">else</span><span class="p">:</span> <span class="n">tail</span> <span class="o">=</span> <span class="s">&#39;&quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">strip</span><span class="p">(),)</span>

    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">text</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span> <span class="n">text</span> <span class="o">=</span> <span class="s">&#39;None&#39;</span>
    <span class="k">else</span><span class="p">:</span> <span class="n">text</span> <span class="o">=</span> <span class="s">&#39;&quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">strip</span><span class="p">(),)</span>

    <span class="k">print</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">tag: </span><span class="si">%s</span><span class="s">  attrib: </span><span class="si">%s</span><span class="s">  tail: </span><span class="si">%s</span><span class="s">  text: </span><span class="si">%s</span><span class="s">&#39;</span> \
      <span class="o">%</span> <span class="p">(</span><span class="n">curLev</span> <span class="o">*</span> <span class="s">&#39;  &#39;</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">attrib</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">text</span><span class="p">,)</span>

    <span class="k">for</span> <span class="n">kid</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
      <span class="n">printNode</span><span class="p">(</span> <span class="n">kid</span><span class="p">,</span> <span class="n">curLev</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">maxLev</span><span class="p">)</span>

<span class="c">#====================================================================</span>
</div>
<div class="viewcode-block" id="parseText"><a class="viewcode-back" href="../../readVasp.html#nrelmat.readVasp.parseText">[docs]</a><span class="k">def</span> <span class="nf">parseText</span><span class="p">(</span> <span class="n">path</span><span class="p">,</span> <span class="n">nmin</span><span class="p">,</span> <span class="n">nmax</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
  <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Splits ``text`` into tokens, and converts each token to ``dtype``.</span>

<span class="sd">  Called by getVec, getRawArray.</span>

<span class="sd">  **Parameters**:</span>

<span class="sd">  * path (str): the XML tree path to the current node, for error msgs.</span>
<span class="sd">  * nmin (int): the minimum num tokens.  If fewer are found, throwerr.</span>
<span class="sd">  * nmax (int): the maximum num tokens.  If more are found, throwerr.</span>
<span class="sd">  * dtype (python type): Either int, float, or str: the tokens</span>
<span class="sd">    are converted to dtype.</span>
<span class="sd">  * text (str): the text string to be split.</span>

<span class="sd">  **Returns**:</span>

<span class="sd">  * list of tokens each having type = dtype.</span>
<span class="sd">  &#39;&#39;&#39;</span>

  <span class="n">toks</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
  <span class="n">ntok</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="n">toks</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ntok</span> <span class="o">&lt;</span> <span class="n">nmin</span><span class="p">:</span>
    <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;ntok &lt; nmin for path: &quot;</span><span class="si">%s</span><span class="s">&quot;  text: &quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">text</span><span class="p">,))</span>
  <span class="k">if</span> <span class="n">nmax</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">ntok</span> <span class="o">&gt;</span> <span class="n">nmax</span><span class="p">:</span>
    <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;ntok &gt; nmax for path: &quot;</span><span class="si">%s</span><span class="s">&quot;  text: &quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">text</span><span class="p">,))</span>

  <span class="n">vals</span> <span class="o">=</span> <span class="n">ntok</span> <span class="o">*</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span>
  <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ntok</span><span class="p">):</span>
    <span class="n">tok</span> <span class="o">=</span> <span class="n">toks</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
      <span class="k">try</span><span class="p">:</span> <span class="n">val</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">tok</span><span class="p">)</span>
      <span class="k">except</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="n">exc</span><span class="p">:</span>
        <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;invalid int in path: &quot;</span><span class="si">%s</span><span class="s">&quot;  text: &quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">text</span><span class="p">,))</span>
    <span class="k">elif</span> <span class="n">dtype</span> <span class="o">==</span> <span class="nb">float</span><span class="p">:</span>
      <span class="k">try</span><span class="p">:</span> <span class="n">val</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span> <span class="n">tok</span><span class="p">)</span>
      <span class="k">except</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="n">exc</span><span class="p">:</span>
        <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;invalid float in path: &quot;</span><span class="si">%s</span><span class="s">&quot;  text: &quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">text</span><span class="p">,))</span>
    <span class="k">elif</span> <span class="n">dtype</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span> <span class="n">val</span> <span class="o">=</span> <span class="n">tok</span>
    <span class="k">else</span><span class="p">:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;unknown dtype for path: &quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">path</span><span class="p">,))</span>
    <span class="n">vals</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
  <span class="k">return</span> <span class="n">vals</span>


<span class="c">#====================================================================</span>
</div>
<div class="viewcode-block" id="getVec"><a class="viewcode-back" href="../../readVasp.html#nrelmat.readVasp.getVec">[docs]</a><span class="k">def</span> <span class="nf">getVec</span><span class="p">(</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">nmin</span><span class="p">,</span> <span class="n">nmax</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
  <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Gets text at the specified XML path, splits, and converts tokens ``dtype``.</span>

<span class="sd">  **Parameters**:</span>

<span class="sd">  * root (xml.etree.ElementTree.Element): The current XML node.</span>
<span class="sd">  * path (str): the XML path from the current node.</span>
<span class="sd">  * nmin (int): the minimum num tokens.  If fewer are found, throwerr.</span>
<span class="sd">  * nmax (int): the maximum num tokens.  If more are found, throwerr.</span>
<span class="sd">  * dtype (python type): Either int, float, or str: the tokens</span>
<span class="sd">    are converted to dtype.</span>

<span class="sd">  **Returns**:</span>

<span class="sd">  * list of tokens each having type = dtype.</span>
<span class="sd">  &#39;&#39;&#39;</span>

  <span class="n">text</span> <span class="o">=</span> <span class="n">getString</span><span class="p">(</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
  <span class="n">vals</span> <span class="o">=</span> <span class="n">parseText</span><span class="p">(</span> <span class="n">path</span><span class="p">,</span> <span class="n">nmin</span><span class="p">,</span> <span class="n">nmax</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">vals</span>

<span class="c">#====================================================================</span>

<span class="c"># Return stripped string</span>
</div>
<div class="viewcode-block" id="getString"><a class="viewcode-back" href="../../readVasp.html#nrelmat.readVasp.getString">[docs]</a><span class="k">def</span> <span class="nf">getString</span><span class="p">(</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
  <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Gets text at the specified XML path, insures there&#39;s just 1, and returns it.</span>

<span class="sd">  **Parameters**:</span>

<span class="sd">  * root (xml.etree.ElementTree.Element): The current XML node.</span>
<span class="sd">  * path (str): the XML path from the current node.</span>

<span class="sd">  **Returns**:</span>

<span class="sd">  * stripped string.</span>
<span class="sd">  &#39;&#39;&#39;</span>

  <span class="n">lst</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span> <span class="n">path</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;path not found: &quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">path</span><span class="p">,))</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;multiple matches for path: &quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">path</span><span class="p">,))</span>
  <span class="n">ele</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">text</span> <span class="o">=</span> <span class="n">ele</span><span class="o">.</span><span class="n">text</span>
  <span class="k">return</span> <span class="n">text</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

<span class="c">#====================================================================</span>
</div>
<div class="viewcode-block" id="getScalar"><a class="viewcode-back" href="../../readVasp.html#nrelmat.readVasp.getScalar">[docs]</a><span class="k">def</span> <span class="nf">getScalar</span><span class="p">(</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
  <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Gets text at the specified XML path, and converts it to ``dtype``.</span>

<span class="sd">  **Parameters**:</span>

<span class="sd">  * root (xml.etree.ElementTree.Element): The current XML node.</span>
<span class="sd">  * path (str): the XML path from the current node.</span>
<span class="sd">  * dtype (python type): Either int, float, or str: the token</span>
<span class="sd">    is converted to dtype.</span>

<span class="sd">  **Returns**:</span>

<span class="sd">  * item having type = dtype.</span>
<span class="sd">  &#39;&#39;&#39;</span>

  <span class="n">lst</span> <span class="o">=</span> <span class="n">getVec</span><span class="p">(</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lst</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="c">#====================================================================</span>
</div>
<div class="viewcode-block" id="getRawArray"><a class="viewcode-back" href="../../readVasp.html#nrelmat.readVasp.getRawArray">[docs]</a><span class="k">def</span> <span class="nf">getRawArray</span><span class="p">(</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">nrow</span><span class="p">,</span> <span class="n">ncol</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
  <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Gets text at the specified XML path, and converts to a</span>
<span class="sd">  2D numpy array of ``dtype``.</span>

<span class="sd">  The text must be organized as one text element per row.</span>

<span class="sd">  **Parameters**:</span>

<span class="sd">  * root (xml.etree.ElementTree.Element): The current XML node.</span>
<span class="sd">  * path (str): the XML path from the current node.</span>
<span class="sd">  * nrow (int): the number of rows.  If 0, allow any number.</span>
<span class="sd">  * ncol (int): the number of columns.  If 0, allow any number.</span>
<span class="sd">  * dtype (python type): Either int, float, or str: the tokens</span>
<span class="sd">    are converted to dtype.</span>

<span class="sd">  **Returns**:</span>

<span class="sd">  * A regular 2-dimensional numpy array of dtype.</span>
<span class="sd">  &#39;&#39;&#39;</span>

  <span class="n">lst</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span> <span class="n">path</span><span class="p">)</span>
  <span class="n">nlst</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="n">lst</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">nlst</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;path not found: &quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">path</span><span class="p">,))</span>
  <span class="k">if</span> <span class="n">nrow</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">nlst</span> <span class="o">!=</span> <span class="n">nrow</span><span class="p">:</span>
    <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;nrow mismatch for path: &quot;</span><span class="si">%s</span><span class="s">&quot;.  expected: </span><span class="si">%d</span><span class="s">  found: </span><span class="si">%d</span><span class="s">&#39;</span> \
      <span class="o">%</span> <span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">nrow</span><span class="p">,</span> <span class="n">nlst</span><span class="p">,))</span>

  <span class="n">rows</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nlst</span><span class="p">):</span>

    <span class="n">ele</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">ele</span><span class="o">.</span><span class="n">text</span>
    <span class="n">vals</span> <span class="o">=</span> <span class="n">parseText</span><span class="p">(</span> <span class="n">path</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">ncolActual</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="n">vals</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ncolActual</span><span class="p">:</span>
      <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;irregular array for path: &quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">path</span><span class="p">,))</span>
    <span class="k">if</span> <span class="n">ncol</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">ncolActual</span> <span class="o">!=</span> <span class="n">ncol</span><span class="p">:</span>
      <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;ncol mismatch path: &quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">path</span><span class="p">,))</span>
    <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">vals</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">dtype</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">amat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">rows</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">dtype</span> <span class="o">==</span> <span class="nb">float</span><span class="p">:</span>
    <span class="n">amat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">rows</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;unknown dtype for path: &quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">path</span><span class="p">,))</span>

  <span class="k">return</span> <span class="n">amat</span>


<span class="c">#====================================================================</span>
</div>
<div class="viewcode-block" id="getArrayByPath"><a class="viewcode-back" href="../../readVasp.html#nrelmat.readVasp.getArrayByPath">[docs]</a><span class="k">def</span> <span class="nf">getArrayByPath</span><span class="p">(</span> <span class="n">bugLev</span><span class="p">,</span> <span class="n">baseNode</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
  <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Converts an XML ``&lt;array&gt;`` element in vasprun.xml</span>
<span class="sd">  to a map with an array.</span>

<span class="sd">  See :func:`getArrayByNode` for details.</span>

<span class="sd">  **Parameters**:</span>

<span class="sd">  * bugLev (int): Debug level.  Normally 0.</span>
<span class="sd">  * baseNode (xml.etree.ElementTree.Element): current XML node</span>
<span class="sd">  * path (str): XML path from baseNode for the ``&lt;array&gt;`` element.</span>

<span class="sd">  **Returns**:</span>

<span class="sd">  * A Python array</span>
<span class="sd">  &#39;&#39;&#39;</span>


  <span class="n">arrNodes</span> <span class="o">=</span> <span class="n">baseNode</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span> <span class="n">path</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrNodes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;path not found&#39;</span><span class="p">)</span>
  <span class="n">res</span> <span class="o">=</span> <span class="n">getArrayByNode</span><span class="p">(</span> <span class="n">bugLev</span><span class="p">,</span> <span class="n">arrNodes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
  <span class="k">return</span> <span class="n">res</span>

<span class="c">#====================================================================</span>


<span class="c"># Returns Mrr == map containing array, like:</span>
<span class="c">#   atomMrr:</span>
<span class="c">#     _dimLens: [6]</span>
<span class="c">#     _dimNames: [&#39;ion&#39;]</span>
<span class="c">#     _fieldNames: [&#39;element&#39;, &#39;atomtype&#39;]</span>
<span class="c">#     _fieldTypes: [&#39;s&#39;, &#39;i&#39;]</span>
<span class="c">#     element: [&#39;Mo&#39; &#39;Mo&#39; &#39;S&#39; &#39;S&#39; &#39;S&#39; &#39;S&#39;]</span>
<span class="c">#     atomtype: [1 1 2 2 2 2]</span>
</div>
<div class="viewcode-block" id="getArrayByNode"><a class="viewcode-back" href="../../readVasp.html#nrelmat.readVasp.getArrayByNode">[docs]</a><span class="k">def</span> <span class="nf">getArrayByNode</span><span class="p">(</span> <span class="n">bugLev</span><span class="p">,</span> <span class="n">arrNode</span><span class="p">):</span>
  <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Converts an XML ``&lt;array&gt;`` element in vasprun.xml</span>
<span class="sd">  to a map with an array.</span>

<span class="sd">  Calls getArraySub to extract each field.</span>
<span class="sd">  The output Python map has the following structure:</span>

<span class="sd">  =============   ========================================================</span>
<span class="sd">  key             value</span>
<span class="sd">  =============   ========================================================</span>
<span class="sd">  _dimLens        numpy vec of dimension lengths.</span>
<span class="sd">                  len( dimLens) == n == numDimensions.</span>
<span class="sd">  _dimNames       numpy vec of dimension names.</span>
<span class="sd">                  len( dimLens) == n == numDimensions.</span>
<span class="sd">  _fieldNames     numpy vec of field names in the parallel arrays.</span>
<span class="sd">                  len( fieldNames) == numVariables.</span>
<span class="sd">  _fieldTypes     numpy vec of field types in the parallel arrays.</span>
<span class="sd">                  len( fieldTypes) == numVariables.</span>
<span class="sd">                  The types are: &#39;i&#39;: int, &#39;f&#39;: float, &#39;s&#39;: str</span>

<span class="sd">  &lt;fieldName&gt;     numpy n-dimensional array of the field &lt;fieldName&gt;</span>
<span class="sd">  &lt;fieldName&gt;     numpy n-dimensional array of the field &lt;fieldName&gt;</span>
<span class="sd">  &lt;fieldName&gt;     numpy n-dimensional array of the field &lt;fieldName&gt;</span>
<span class="sd">  ...</span>
<span class="sd">  =============   ========================================================</span>

<span class="sd">  Example XML for a 1-dimensional array with 2 fields: ::</span>

<span class="sd">    &lt;array name=&quot;atoms&quot; &gt;</span>
<span class="sd">     &lt;dimension dim=&quot;1&quot;&gt;ion&lt;/dimension&gt;</span>
<span class="sd">     &lt;field type=&quot;string&quot;&gt;element&lt;/field&gt;</span>
<span class="sd">     &lt;field type=&quot;int&quot;&gt;atomtype&lt;/field&gt;</span>
<span class="sd">     &lt;set&gt;</span>
<span class="sd">      &lt;rc&gt;&lt;c&gt;C &lt;/c&gt;&lt;c&gt;   1&lt;/c&gt;&lt;/rc&gt;</span>
<span class="sd">      &lt;rc&gt;&lt;c&gt;Fe&lt;/c&gt;&lt;c&gt;   2&lt;/c&gt;&lt;/rc&gt;</span>
<span class="sd">      &lt;rc&gt;&lt;c&gt;Fe&lt;/c&gt;&lt;c&gt;   2&lt;/c&gt;&lt;/rc&gt;</span>
<span class="sd">      &lt;rc&gt;&lt;c&gt;Fe&lt;/c&gt;&lt;c&gt;   2&lt;/c&gt;&lt;/rc&gt;</span>
<span class="sd">      &lt;rc&gt;&lt;c&gt;Fe&lt;/c&gt;&lt;c&gt;   2&lt;/c&gt;&lt;/rc&gt;</span>
<span class="sd">     &lt;/set&gt;</span>
<span class="sd">    &lt;/array&gt;</span>

<span class="sd">  Example resulting map: ::</span>

<span class="sd">    _dimLens: [5]</span>
<span class="sd">    _dimNames: [&#39;ion&#39;]</span>
<span class="sd">    _fieldNames: [&#39;element&#39; &#39;atomtype&#39;]</span>
<span class="sd">    _fieldTypes: [&#39;s&#39; &#39;i&#39;]</span>
<span class="sd">    element: [&#39;C&#39; &#39;Fe&#39; &#39;Fe&#39; &#39;Fe&#39; &#39;Fe&#39;]</span>
<span class="sd">    atomtype: [1 2 2 2 2]</span>

<span class="sd">  Multiple dimension arrays also are supported.</span>

<span class="sd">  The vasprun.xml handling of dimensions is unusual.</span>
<span class="sd">  What they claim is ``dim=&quot;1&quot;`` actually is the least</span>
<span class="sd">  significant dimension and varies fastest, both</span>
<span class="sd">  in the XML data and in our resulting Python array.</span>

<span class="sd">  So the XML ``&lt;dimension dim=&quot;1&quot;&gt;band&lt;/dimension&gt;``</span>
<span class="sd">  becomes the last dimension in the resulting Python array.</span>

<span class="sd">  Example XML for a 3 dimensional array with 2 fields: ::</span>

<span class="sd">    &lt;array&gt;</span>
<span class="sd">     &lt;dimension dim=&quot;1&quot;&gt;band&lt;/dimension&gt;</span>
<span class="sd">     &lt;dimension dim=&quot;2&quot;&gt;kpoint&lt;/dimension&gt;</span>
<span class="sd">     &lt;dimension dim=&quot;3&quot;&gt;spin&lt;/dimension&gt;</span>
<span class="sd">     &lt;field&gt;eigene&lt;/field&gt;</span>
<span class="sd">     &lt;field&gt;occ&lt;/field&gt;</span>
<span class="sd">     &lt;set&gt;</span>
<span class="sd">      &lt;set comment=&quot;spin 1&quot;&gt;</span>
<span class="sd">       &lt;set comment=&quot;kpoint 1&quot;&gt;</span>
<span class="sd">        &lt;r&gt;   -6.5058    1.0000 &lt;/r&gt;</span>
<span class="sd">        &lt;r&gt;    0.2537    1.0000 &lt;/r&gt;</span>
<span class="sd">        &lt;r&gt;    0.7101    1.0000 &lt;/r&gt;</span>
<span class="sd">        ...</span>
<span class="sd">        &lt;r&gt;    8.1390    0.0000 &lt;/r&gt;</span>
<span class="sd">       &lt;/set&gt;</span>
<span class="sd">       &lt;set comment=&quot;kpoint 2&quot;&gt;</span>
<span class="sd">        &lt;r&gt;   -6.3718    1.0000 &lt;/r&gt;</span>
<span class="sd">        &lt;r&gt;   -0.0841    1.0000 &lt;/r&gt;</span>
<span class="sd">        &lt;r&gt;    0.7508    1.0000 &lt;/r&gt;</span>
<span class="sd">       ...</span>
<span class="sd">       &lt;/set&gt;</span>
<span class="sd">       &lt;set comment=&quot;kpoint 101&quot;&gt;</span>
<span class="sd">        &lt;r&gt;   -5.8567    1.0000 &lt;/r&gt;</span>
<span class="sd">        &lt;r&gt;   -0.0854    1.0000 &lt;/r&gt;</span>
<span class="sd">        &lt;r&gt;    0.9602    1.0000 &lt;/r&gt;</span>
<span class="sd">        &lt;r&gt;    7.7174    0.0000 &lt;/r&gt;</span>
<span class="sd">        &lt;r&gt;    7.8556    0.0000 &lt;/r&gt;</span>
<span class="sd">       &lt;/set&gt;</span>
<span class="sd">      &lt;/set&gt;</span>
<span class="sd">     &lt;/set&gt;</span>
<span class="sd">    &lt;/array&gt;</span>

<span class="sd">  Example resulting map: ::</span>

<span class="sd">    _dimLens: [  1 101  22]</span>
<span class="sd">    _dimNames: [&#39;spin&#39; &#39;kpoint&#39; &#39;band&#39;]</span>
<span class="sd">    _fieldNames: [&#39;eigene&#39; &#39;occ&#39;]</span>
<span class="sd">    _fieldTypes: [&#39;f&#39; &#39;f&#39;]</span>
<span class="sd">    eigene: [[[-6.5058  0.2537  0.7101 ...,  7.6096  7.8817  8.139 ]</span>
<span class="sd">        [-6.3718 -0.0841  0.7508 ...,  7.481   7.8491  7.9595]</span>
<span class="sd">        [-6.1332 -0.611   1.0672 ...,  7.0857  7.8655  7.9314]</span>
<span class="sd">        ...,</span>
<span class="sd">        [-5.8462  0.3687  0.9498 ...,  7.1721  7.4739  7.6631]</span>
<span class="sd">        [-5.8016  0.5503  0.5886 ...,  7.4113  7.5794  7.7332]</span>
<span class="sd">        [-5.8567 -0.0854  0.9602 ...,  7.2729  7.7174  7.8556]]]</span>
<span class="sd">    occ: [[[ 1.      1.      1.     ...,  0.      0.      0.    ]</span>
<span class="sd">        [ 1.      1.      1.     ...,  0.      0.      0.    ]</span>
<span class="sd">        [ 1.      1.      1.     ...,  1.      0.      0.    ]</span>
<span class="sd">        ...,</span>
<span class="sd">        [ 1.      1.      1.     ...,  1.      0.      0.    ]</span>
<span class="sd">        [ 1.      1.      1.     ...,  0.      0.      0.    ]</span>
<span class="sd">        [ 1.      1.      1.     ...,  0.9751  0.      0.    ]]]</span>


<span class="sd">  **Parameters**:</span>

<span class="sd">  * bugLev (int): Debug level.  Normally 0.</span>
<span class="sd">  * node (xml.etree.ElementTree.Element):</span>
<span class="sd">    The XML node for the ``&lt;array&gt;`` element.</span>

<span class="sd">  **Returns**:</span>

<span class="sd">  * A Python array</span>
<span class="sd">  &#39;&#39;&#39;</span>

  <span class="n">dimNodes</span> <span class="o">=</span> <span class="n">arrNode</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;dimension&#39;</span><span class="p">)</span>
  <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="n">dimNodes</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;no dimensions found&#39;</span><span class="p">)</span>
  <span class="n">dimNames</span> <span class="o">=</span> <span class="p">[</span><span class="n">nd</span><span class="o">.</span><span class="n">text</span> <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="n">dimNodes</span><span class="p">]</span>
  <span class="n">dimNames</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>         <span class="c"># dimNames are in reverse order in XML</span>
  <span class="n">dimNames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">dimNames</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
  <span class="n">dimLens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">[</span><span class="n">ndim</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

  <span class="n">fieldNodes</span> <span class="o">=</span> <span class="n">arrNode</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;field&#39;</span><span class="p">)</span>
  <span class="n">nfield</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="n">fieldNodes</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">nfield</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;no fields found&#39;</span><span class="p">)</span>
  <span class="n">fieldNames</span> <span class="o">=</span> <span class="p">[</span><span class="n">nd</span><span class="o">.</span><span class="n">text</span> <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="n">fieldNodes</span><span class="p">]</span>
  <span class="n">fieldNames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">fieldNames</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>

  <span class="c"># We set fieldTypes[ifield] to max( all found types for ifield)</span>
  <span class="c"># Types are: 0:int, 1:float, 2:string</span>
  <span class="n">fieldTypes</span> <span class="o">=</span> <span class="n">nfield</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

  <span class="n">setNodes</span> <span class="o">=</span> <span class="n">arrNode</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;set&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">setNodes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;wrong len for primary set&#39;</span><span class="p">)</span>
  <span class="n">setNode</span> <span class="o">=</span> <span class="n">setNodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">resList</span> <span class="o">=</span> <span class="n">nfield</span> <span class="o">*</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span>
  <span class="k">for</span> <span class="n">ifield</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nfield</span><span class="p">):</span>
    <span class="n">amat</span> <span class="o">=</span> <span class="n">getArraySub</span><span class="p">(</span>
      <span class="n">bugLev</span><span class="p">,</span>
      <span class="n">setNode</span><span class="p">,</span>
      <span class="n">ifield</span><span class="p">,</span>
      <span class="n">fieldTypes</span><span class="p">,</span>
      <span class="mi">0</span><span class="p">,</span>            <span class="c"># idim</span>
      <span class="n">dimLens</span><span class="p">)</span>

    <span class="c"># Convert all elements of each field ifield to fieldTypes[ifield].</span>
    <span class="k">if</span>   <span class="n">fieldTypes</span><span class="p">[</span><span class="n">ifield</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">amat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">amat</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">fieldTypes</span><span class="p">[</span><span class="n">ifield</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="n">amat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">amat</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">fieldTypes</span><span class="p">[</span><span class="n">ifield</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="n">amat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">amat</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;unknown fieldType&#39;</span><span class="p">)</span>

    <span class="n">resList</span><span class="p">[</span><span class="n">ifield</span><span class="p">]</span> <span class="o">=</span> <span class="n">amat</span>

  <span class="c"># Convert fieldTypes from 0,1,2 to &#39;i&#39;, &#39;f&#39;, &#39;s&#39;</span>
  <span class="n">fldMap</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">:</span><span class="s">&#39;i&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="s">&#39;f&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="s">&#39;s&#39;</span><span class="p">}</span>
  <span class="n">fieldTypeStgs</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">fldMap</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">fieldTypes</span><span class="p">)</span>
  <span class="n">fieldTypeStgs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">fieldTypeStgs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>

  <span class="n">resMap</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;_dimNames&#39;</span><span class="p">:</span> <span class="n">dimNames</span><span class="p">,</span>
    <span class="s">&#39;_dimLens&#39;</span><span class="p">:</span> <span class="n">dimLens</span><span class="p">,</span>
    <span class="s">&#39;_fieldNames&#39;</span><span class="p">:</span> <span class="n">fieldNames</span><span class="p">,</span>
    <span class="s">&#39;_fieldTypes&#39;</span><span class="p">:</span> <span class="n">fieldTypeStgs</span><span class="p">,</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fieldNames</span><span class="p">)):</span>
    <span class="n">ar</span> <span class="o">=</span> <span class="n">resList</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">ar</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dimLens</span><span class="p">)):</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;dimLens mismatch&#39;</span><span class="p">)</span>
    <span class="n">resMap</span><span class="p">[</span><span class="n">fieldNames</span><span class="p">[</span><span class="n">ii</span><span class="p">]]</span> <span class="o">=</span> <span class="n">ar</span>

  <span class="k">return</span> <span class="n">resMap</span>


<span class="c">#====================================================================</span>

</div>
<div class="viewcode-block" id="getArraySub"><a class="viewcode-back" href="../../readVasp.html#nrelmat.readVasp.getArraySub">[docs]</a><span class="k">def</span> <span class="nf">getArraySub</span><span class="p">(</span>
  <span class="n">bugLev</span><span class="p">,</span>
  <span class="n">setNode</span><span class="p">,</span>
  <span class="n">ifield</span><span class="p">,</span>
  <span class="n">fieldTypes</span><span class="p">,</span>
  <span class="n">idim</span><span class="p">,</span>
  <span class="n">dimLens</span><span class="p">):</span>
  <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Decodes the XML for one field (one variable) for an</span>
<span class="sd">  ``&lt;array&gt;``.</span>

<span class="sd">  Called by getArrayByNode.  See :func:`getArrayByNode` for details.</span>

<span class="sd">  **Parameters**:</span>

<span class="sd">  * bugLev (int): Debug level.  Normally 0.</span>
<span class="sd">  * setNode (xml.etree.ElementTree.Element): the element for ``&lt;set&gt;``.</span>
<span class="sd">  * ifield (int): the index number of the field.</span>
<span class="sd">  * fieldTypes (int[]): the numeric field types so far.</span>
<span class="sd">    The numeric types are: 0: int, 1: float, 2: str.</span>
<span class="sd">    We take the max of the field types.</span>
<span class="sd">  * tp (Python type): The desired type.</span>
<span class="sd">  * idim (int): dimension number == recursion level == array nest level.</span>
<span class="sd">    0 on the first call, 1 for the next level array, etc.</span>
<span class="sd">  * dimLens (int[]): list of dimension lengths.  Updated.</span>

<span class="sd">  **Returns**:</span>

<span class="sd">  * A Python array with elements of type str.</span>
<span class="sd">    The caller converts them to the correct type.</span>
<span class="sd">  &#39;&#39;&#39;</span>


  <span class="n">nfield</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fieldTypes</span><span class="p">)</span>
  <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dimLens</span><span class="p">)</span>

  <span class="c"># If we&#39;re at the last dimension, decode the element values.</span>
  <span class="k">if</span> <span class="n">idim</span> <span class="o">==</span> <span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
    <span class="c"># Try long form:</span>
    <span class="c">#   &lt;set&gt;</span>
    <span class="c">#     &lt;rc&gt;</span>
    <span class="c">#       &lt;c&gt;2&lt;/c&gt;</span>
    <span class="c">#       &lt;c&gt;Mo&lt;/c&gt;</span>
    <span class="n">rcNodes</span> <span class="o">=</span> <span class="n">setNode</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;rc&#39;</span><span class="p">)</span>     <span class="c"># long form: &lt;rc&gt; &lt;c&gt;</span>

    <span class="c"># Try short form:</span>
    <span class="c">#   &lt;set comment=&#39;spin 1&#39;&gt;</span>
    <span class="c">#     &lt;set comment=&#39;kpoint 1&#39;&gt;</span>
    <span class="c">#       &lt;r&gt;-30.3711 1.0000&lt;/r&gt;</span>
    <span class="c">#       &lt;r&gt;-30.3709 1.0000&lt;/r&gt;</span>
    <span class="n">rNodes</span> <span class="o">=</span> <span class="n">setNode</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;r&#39;</span><span class="p">)</span>       <span class="c"># short form: &lt;r&gt;</span>

    <span class="n">nval</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">rcNodes</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span> <span class="n">rNodes</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">dimLens</span><span class="p">[</span><span class="n">idim</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">dimLens</span><span class="p">[</span><span class="n">idim</span><span class="p">]</span> <span class="o">=</span> <span class="n">nval</span>
    <span class="k">if</span> <span class="n">nval</span> <span class="o">!=</span> <span class="n">dimLens</span><span class="p">[</span><span class="n">idim</span><span class="p">]:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;irregular array&#39;</span><span class="p">)</span>
    <span class="n">resVec</span> <span class="o">=</span> <span class="n">nval</span> <span class="o">*</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rcNodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>                <span class="c"># long form: &lt;rc&gt; &lt;c&gt;</span>
      <span class="k">for</span> <span class="n">ival</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nval</span><span class="p">):</span>
        <span class="n">cNodes</span> <span class="o">=</span> <span class="n">rcNodes</span><span class="p">[</span><span class="n">ival</span><span class="p">]</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;c&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cNodes</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nfield</span><span class="p">:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;wrong num fields&#39;</span><span class="p">)</span>
        <span class="n">stg</span> <span class="o">=</span> <span class="n">cNodes</span><span class="p">[</span><span class="n">ifield</span><span class="p">]</span><span class="o">.</span><span class="n">text</span>
        <span class="n">resVec</span><span class="p">[</span><span class="n">ival</span><span class="p">]</span> <span class="o">=</span> <span class="n">stg</span>

    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">rNodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>               <span class="c"># short form: &lt;r&gt;</span>
      <span class="k">for</span> <span class="n">ival</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nval</span><span class="p">):</span>
        <span class="n">txt</span> <span class="o">=</span> <span class="n">rNodes</span><span class="p">[</span><span class="n">ival</span><span class="p">]</span><span class="o">.</span><span class="n">text</span>
        <span class="n">toks</span> <span class="o">=</span> <span class="n">txt</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">toks</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nfield</span><span class="p">:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;wrong num fields&#39;</span><span class="p">)</span>
        <span class="n">resVec</span><span class="p">[</span><span class="n">ival</span><span class="p">]</span> <span class="o">=</span> <span class="n">toks</span><span class="p">[</span><span class="n">ifield</span><span class="p">]</span>

    <span class="k">else</span><span class="p">:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;unknown array structure&#39;</span><span class="p">)</span>

    <span class="c"># Strip all strings.</span>
    <span class="c"># Set fieldTypes[ifield] to max( current type, all found types)</span>
    <span class="c"># Types are: 0:int, 1:float, 2:string</span>
    <span class="k">for</span> <span class="n">ival</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nval</span><span class="p">):</span>
      <span class="n">resVec</span><span class="p">[</span><span class="n">ival</span><span class="p">]</span> <span class="o">=</span> <span class="n">resVec</span><span class="p">[</span><span class="n">ival</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
      <span class="n">stg</span> <span class="o">=</span> <span class="n">resVec</span><span class="p">[</span><span class="n">ival</span><span class="p">]</span>
      <span class="n">ftype</span> <span class="o">=</span> <span class="mi">2</span>            <span class="c"># assume worst case: string</span>
      <span class="k">try</span><span class="p">:</span>
        <span class="nb">float</span><span class="p">(</span> <span class="n">stg</span><span class="p">)</span>
        <span class="n">ftype</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span> <span class="k">pass</span>
      <span class="k">try</span><span class="p">:</span>
        <span class="nb">int</span><span class="p">(</span> <span class="n">stg</span><span class="p">)</span>
        <span class="n">ftype</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span> <span class="k">pass</span>
      <span class="n">fieldTypes</span><span class="p">[</span><span class="n">ifield</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span> <span class="n">fieldTypes</span><span class="p">[</span><span class="n">ifield</span><span class="p">],</span> <span class="n">ftype</span><span class="p">)</span>


  <span class="k">else</span><span class="p">:</span>    <span class="c"># else idim &lt; ndim - 1.  Recursion.</span>
    <span class="n">setNodes</span> <span class="o">=</span> <span class="n">setNode</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;set&#39;</span><span class="p">)</span>
    <span class="n">nset</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="n">setNodes</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dimLens</span><span class="p">[</span><span class="n">idim</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">dimLens</span><span class="p">[</span><span class="n">idim</span><span class="p">]</span> <span class="o">=</span> <span class="n">nset</span>
    <span class="k">if</span> <span class="n">nset</span> <span class="o">!=</span> <span class="n">dimLens</span><span class="p">[</span><span class="n">idim</span><span class="p">]:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;irregular array&#39;</span><span class="p">)</span>
    <span class="n">resVec</span> <span class="o">=</span> <span class="n">nset</span> <span class="o">*</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">iset</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nset</span><span class="p">):</span>
      <span class="n">resVec</span><span class="p">[</span><span class="n">iset</span><span class="p">]</span> <span class="o">=</span> <span class="n">getArraySub</span><span class="p">(</span>          <span class="c"># recursion</span>
        <span class="n">bugLev</span><span class="p">,</span>
        <span class="n">setNodes</span><span class="p">[</span><span class="n">iset</span><span class="p">],</span>
        <span class="n">ifield</span><span class="p">,</span>
        <span class="n">fieldTypes</span><span class="p">,</span>
        <span class="n">idim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">dimLens</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">resVec</span>
 

<span class="c">#====================================================================</span>

</div>
<div class="viewcode-block" id="convertTypes"><a class="viewcode-back" href="../../readVasp.html#nrelmat.readVasp.convertTypes">[docs]</a><span class="k">def</span> <span class="nf">convertTypes</span><span class="p">(</span> <span class="n">tp</span><span class="p">,</span> <span class="n">vec</span><span class="p">):</span>
  <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Recursively converts the elements of an array ``vec``</span>
<span class="sd">  from str to the specified type.</span>

<span class="sd">  **Parameters**:</span>

<span class="sd">  * tp (Python type): The desired type.</span>
<span class="sd">  * vec (str[] or str[][] or ...): the array to be converted.</span>

<span class="sd">  **Returns**:</span>

<span class="sd">  * A Python array with elements of type ``tp``.</span>
<span class="sd">  &#39;&#39;&#39;</span>

  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vec</span><span class="p">)):</span>
      <span class="n">vec</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">tp</span><span class="p">(</span> <span class="n">vec</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>
  <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">subVec</span> <span class="ow">in</span> <span class="n">vec</span><span class="p">:</span>
      <span class="n">convertTypes</span><span class="p">(</span> <span class="n">tp</span><span class="p">,</span> <span class="n">subVec</span><span class="p">)</span>             <span class="c"># recursion</span>
  <span class="k">else</span><span class="p">:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;unknown array structure&#39;</span><span class="p">)</span>

<span class="c">#====================================================================</span>

</div>
<span class="k">def</span> <span class="nf">maxAbsDiff</span><span class="p">(</span> <span class="n">mata</span><span class="p">,</span> <span class="n">matb</span><span class="p">):</span>
  <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Returns the max abs diff between two 2D numpy matrices.</span>

<span class="sd">  **Parameters**:</span>

<span class="sd">  * mata (numpy 2D array): Array to be compared.</span>
<span class="sd">  * matb (numpy 2D array): Array to be compared.</span>

<span class="sd">  **Returns**:</span>

<span class="sd">  * float scalar: max_i( max_j( abs( mata[i][j] - matb[i][j]))</span>
<span class="sd">  &#39;&#39;&#39;</span>

  <span class="p">(</span><span class="n">nrow</span><span class="p">,</span><span class="n">ncol</span><span class="p">)</span> <span class="o">=</span> <span class="n">mata</span><span class="o">.</span><span class="n">shape</span>
  <span class="k">if</span> <span class="n">matb</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">mata</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span> <span class="n">throwerr</span><span class="p">(</span><span class="s">&#39;maxAbsDiff: shape mismatch&#39;</span><span class="p">)</span>
  <span class="n">diffMat</span> <span class="o">=</span>  <span class="nb">abs</span><span class="p">(</span> <span class="n">matb</span> <span class="o">-</span> <span class="n">mata</span><span class="p">)</span>
  <span class="n">res</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span> <span class="nb">map</span><span class="p">(</span> <span class="nb">max</span><span class="p">,</span> <span class="n">diffMat</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">res</span>

<span class="c">#====================================================================</span>

<span class="k">def</span> <span class="nf">calcMatDeltas</span><span class="p">(</span> <span class="n">mats</span><span class="p">):</span>
  <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Returns the max abs diffs between adjacent pairs of a</span>
<span class="sd">  list of 2D numpy matrices.</span>

<span class="sd">  **Parameters**:</span>

<span class="sd">  * mats (list of 2D numpy matrices)</span>

<span class="sd">  **Returns**:</span>

<span class="sd">  * deltas (float[]): deltas[k] = maxAbsDiff( mats[k-1], mats[k])</span>
<span class="sd">  &#39;&#39;&#39;</span>

  <span class="n">nmat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="n">mats</span><span class="p">)</span>
  <span class="n">deltas</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nmat</span><span class="p">):</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">maxAbsDiff</span><span class="p">(</span> <span class="n">mats</span><span class="p">[</span><span class="n">ii</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">mats</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>
    <span class="n">deltas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">delta</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">deltas</span>

<span class="c">#====================================================================</span>

<span class="k">def</span> <span class="nf">printMrr</span><span class="p">(</span> <span class="n">vmap</span><span class="p">):</span>
  <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Prints the Mrr map returned by getArrayByPath or getArrayByNode.</span>

<span class="sd">  **Parameters**:</span>

<span class="sd">  * vmap (map): the MRR map</span>

<span class="sd">  **Returns**:</span>

<span class="sd">  * None</span>
<span class="sd">  &#39;&#39;&#39;</span>

  <span class="n">keys</span> <span class="o">=</span> <span class="n">vmap</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
  <span class="n">keys</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
  <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">):</span>
      <span class="n">val</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
      <span class="k">print</span> <span class="s">&#39;  </span><span class="si">%s</span><span class="s">: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,)</span>
  <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">vmap</span><span class="p">[</span><span class="s">&#39;_fieldNames&#39;</span><span class="p">]:</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="k">print</span> <span class="s">&#39;  </span><span class="si">%s</span><span class="s">: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,)</span>
  <span class="k">print</span> <span class="s">&#39;&#39;</span>

<span class="c">#====================================================================</span>

<div class="viewcode-block" id="throwerr"><a class="viewcode-back" href="../../readVasp.html#nrelmat.readVasp.throwerr">[docs]</a><span class="k">def</span> <span class="nf">throwerr</span><span class="p">(</span> <span class="n">msg</span><span class="p">):</span>
  <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Prints an error message and raises Exception.</span>

<span class="sd">  **Parameters**:</span>

<span class="sd">  * msg (str): Error message.</span>

<span class="sd">  **Returns**</span>

<span class="sd">  * (Never returns)</span>
<span class="sd">  </span>
<span class="sd">  **Raises**</span>

<span class="sd">  * Exception</span>
<span class="sd">  &#39;&#39;&#39;</span>

  <span class="k">print</span> <span class="n">msg</span>
  <span class="k">print</span> <span class="o">&gt;&gt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">,</span> <span class="n">msg</span>
  <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span> <span class="n">msg</span><span class="p">)</span>

<span class="c">#====================================================================</span>
</div>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span> <span class="n">main</span><span class="p">()</span>

<span class="c">#====================================================================</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">nrelmat 1.0.0 documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, S. Sullivan.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2b1.
    </div>
  </body>
</html>